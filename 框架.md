# 1.说一下IOC和AOP？
IOC是依赖反转，通过依赖注入DI实现IOC。主要思想是面向抽象编程而不是面向具体实现编程。反转的意思是从依赖具体  
实现变为依赖抽象。
AOP是面向切面编程，通过代理对代码无侵入的添加功能，实现切面编程。比如事务、日志等模块。
代理机制主要有jdk提供的动态代理和cglib提供的字节码动态代码。


# 2.Spring中Bean的生命周期。
1. 首先这个bean在进行开始实例化的时候会先进行调用该类的构造函数，默认是单例的
2. 然后去注入属性中的bean
3. 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
4. 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
5. 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
6. 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
7. 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
8. 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
9. 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
10. 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；

# 3.Spring中注解Autowired和Resource的区别？ 

共同点:  
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。  
不同点 :  
（1）@Autowired 为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;  
只按照byType注入。 @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，  
可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。  
（2）@Resource 默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：  
name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，  
则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射  
机制使用byName自动注入策略。如果按name找不到对应的bean的话回退到ByType的自动注入策略。

# 4.@Controller和@RestController的区别？ 
@Controller

    方法的返回值。默认是视图页面的跳转路径。
    如果想返回json对象，必须在方法的上面加@ResponseBody

@RestController

    方法返回值，默认是json对象，也就是相当于@Controller里面的方法上添加了@ResponseBody
    如果方法返回值需要跳转视图页面的话，那么方法的返回类型必须是View 或者ModelAndView.
    
    
# 5.依赖注入的方式有哪几种？

1. set方法注入
2. 构造器注入
3. 注解注入

# 6.Spring中IOC的原理？
第一个过程是Resource定位过程。这个Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。对于这些BeanDefinition的存在形式，相信大家都不会感到陌生。比如，在文件系统中的Bean定义信息可以使用FileSystemResource来进行抽象；在类路径中的Bean定义信息可以使用前面提到的ClassPathResource来使用，等等。这个定位过程类似于容器寻找数据的过程，就像用水桶装水先要把水找到一样。

第二个过程是BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IoC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。下面介绍这个数据结构的详细定义。具体来说，这个BeanDefinition实际上就是POJO对象在IoC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IoC容器能够方便地对POJO对象也就是Bean进行管理。在下面的章节中，我们会对这个载入的过程进行详细的分析，使大家对整个过程有比较清楚的了解。
 
第三个过程是向IoC容器注册这些BeanDefinition的过程。这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册。通过分析，我们可以看到，在IoC容器内部将BeanDefinition注入到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。值得注意的是，这里谈的是IoC容器初始化过程，在这个过程中，一般不包含Bean依赖注入的实现。在Spring IoC的设计中，Bean定义的载入和依赖注入是两个独立的过程。依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。但有一个例外值得注意，在使用IoC容器时有一个预实例化的配置，通过这个预实例化的配置（具体来说，可以通过为Bean定义信息中的lazyinit属性），用户可以对容器初始化过程作一个微小的控制，从而改变这个被设置了lazyinit属性的Bean的依赖注入过程。


# Spring容器如何创建？
在web.xml文件中配置ServletContextListener为spring的环境启动监听器。
然后启动的时候，读取配置好的xml文件，解析这个xml文件，根据xml文件中的bean定义，生成实例，填入到Bean容器中。之后就是注入了。


# SpringMVC容器和Spring容器的区别？
Spring是web.xml中注册启动监听器时，读取spring相关的xml去生成bean，放入容器。
SringMVC是web.xml中注册的一个Servlet，一般来说所有请求都经过这个servlet，这个serlvet在初始化的时候  
读取springmvc.xml中的数据，扫描指定的包，注册好所有Controller,解析请求对应的方法，放入一个Map中，当  
有请求进来的时候就从这个map中取对应的Controller。

# SpringMVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？
是单例的，如果使用Controller中的实例变量的话，多线程会有问题。解决办法是，不要使用共享变量，或者使用ThreadLocal。

# Spring事务管理类型？
编程式和声明式
    
# 7.Spring中BeanFactory和ApplicationContext的区别？
BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。

BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。  
而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。

ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。

加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建  
所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是启动时间会比较耗时。


# 8.什么是IoC和DI？DI是如何实现的？ 
IOC是控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，遵循了依赖倒置的原则。可以用来减低计算机代码  
之间的耦合度。控制指的是对实现类的控制,反转指的是这种控制权从调用类中移除,交给第三方（容器）决定。
而控制反转其中最常见实现方式叫做依赖注入（Dependency Injection，简称DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有  
对象的外界实体，将其所依赖的对象的引用传递(注入)给它。
还有一种ioc的实现方式叫“依赖查找”（Dependency Lookup），但Martin Fowler认为DI的实现方式更灵活解耦。


# 9.请问Spring中Bean的作用域有哪些？
1. singleton为默认值，IOC容器中仅存在一个Bean实例，Bean都以单例模式存在
2. prototype，在每次请求获取Bean的时候，都会创建一个新的实例，它在容器初始化的时候不会创建实例，采用的是延迟加载的形式注入
Bean，当你使用的时候，才会进行实例化，每次实例化获取的对象都不是同一个 就像BeanFactory的实例化模式 实例不唯一
3. request，在每一次http请求时会创建一个实例，该实例仅在当前http request有效
4. session，在每一次http请求时会创建一个实例，该实例仅在当前http session有效
5. globalSession，全局Session，仅供基于Porlet的web环境进行使用。（很少使用到）

# Spring容器对Bean组件是如何管理的？
1.Bean对象创建的时机：懒加载或饥饿加载
2.Bean对象创建的个数：原型或者单例
3.Bean对象初始化和销毁：可配置初始化或者销毁调用的方法。
4.实例化Bean地方时：构造器、静态工厂、实例工厂

# 10.请谈一谈Spring中自动装配的方式有哪些？

1. no：不进行自动装配，手动设置Bean的依赖关系。
2. byName：根据Bean的名字进行自动装配。
3. byType：根据Bean的类型进行自动装配。
4. constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
5. autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配


# 11.aop的应用场景？ 
1. 事务
2. 权限
3. 日志
4. 缓存
5. 性能统计


# 12.AOP的原理？


```
Spring AOP中的代理使用的默认策略是：
如果目标对象实现了接口，则默认采用JDK动态代理
如果目标对象没有实现接口，则采用CgLib进行动态代理
如果目标对象实现了接口，且强制CgLib代理，则采用CgLib进行动态代理
```


# 13.你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？ 


- 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。
- 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。
- 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。
说明： Advice在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。
- 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。
- 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：1.编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；2.装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；3.运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。
- 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。

# 14.请问Spring支持的事务管理类型有哪些？

1. 声明式事务
本质使用AOP，将业务和事务管理分离，降低耦合度和提高事务的复用能力。声明式事务可以通过注解@Transactional和配置来管理事务，  
操作简单。

2. 编程式事务
编程式事务是在代码中使用TransactionTemplate进行硬编码，与业务的耦合度高，难以复用。但控制事务的范围比较灵活。

# Spring事务的传播特性？

1.PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
2.PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
3.PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
4.PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
5.PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
6.PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常
7.PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行


# Spring事务的隔离级别？
ISOLATION_READ_UNCOMMITTED 读未提交
ISOLATION_READ_COMMITTED 读已提交
ISOLATION_REPEATABLE_READ 可重复读
ISOLATION_SERIALIZABLE 串行读

# Spring的通知类型有哪些？
前置通知、正常返回通知、异常返回通知、返回通知、环绕通知

# 15.Spring的优点？
- 降低了组件之间的耦合性，实现了软件各层之间的解耦
- 可以使用容易提供的众多服务，如事务管理，消息服务等
- 容器提供单例模式支持
- 容器提供了 AOP 技术，利用它很容易实现如权限拦截，运行期监控等功能
- 容器提供了众多的辅助类，能加快应用的开发
- spring 对于主流的应用框架提供了集成支持，如 hibernate，JPA，Struts 等
- spring 属于低侵入式设计，代码的污染极低
- 独立于各种应用服务器
- spring 的 DI 机制降低了业务对象替换的复杂性
- Spring 的高度开放性，并不强制应用完全依赖于 Spring，开发者可以自由选择 spring 的部分或全部

# 16.请阐述一下Hibernate实体对象的三种状态是什么？以及对应的转换关系是什么？？
瞬时态，持久态和游离态。
瞬时态没有id，对象刚new出来的时候处于瞬时态。
持久态有id（与数据库中的主键关联）,通过get()或者load()方法获取的对象处于持久态。
游离态:持久态的对象脱离了session的管理变成游离态，处于游离态的对象如果不被其它对象引用则会被垃圾回收机制回收。
转化：
瞬时转持久：Session对象的save()或saveOrUpdate()方法保存对象
持久转瞬时，调用delete()方法
持久转游离：调用Session对象的clear()/close()/evict()
游离转瞬时：调用delete()方法
游离转持久: 调用update()或者saveOrUpdate() 

# 17.Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？
SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。  
SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。  
Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。  
Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。  
Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal  
将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的  
getCurrentSession()方法就可以做到。


# 18.Hibernate中Session的load和get方法的区别是什么？
1. 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
2. get方法直接返回实体类对象，load方法返回实体类对象的代理(如果lazy='true' ，就使用延迟加载，返回的是代理，不是真实对象)。
3. 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，  
直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对  
二级缓存只写不读，它也是可以访问二级缓存的。

# 19.如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？

    延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现  
    延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多  
    的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用  
    getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关  
    闭了。

    延迟加载与session关闭的矛盾一般可以这样处理： 
    1. 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，  
    但这种解决方案存在明显的缺陷。首先，出现"no session or session was closed"通常说明系统中已经存在主外键关联，  
    如果去掉延迟加载的话，每次查询的开销都会变得很大。 
    2. 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没
    有被加载则可以使用Hibernate.initialize()方法加载对象。 
    3. 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和  
    OpenSessionInViewInterceptor就是这种做法。
  
# 20.解释一下MyBatis中命名空间（namespace）的作用。
    在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。  
    为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中  
    的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，  
    即使在不同映射文件中的语句ID相同，也不会再产生冲突了。

# 21.MyBatis中的动态SQL是什么意思？
    MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。
    
# MyBatis中#和$的区别？
$通过直接拼接进sql中，#是预编译再填入参数。所以$不安全，#较安全。
    
# MyBatis一级缓存原理以及失效情况？
一级缓存的作用域在session级别，在一个事务中，两次查询用的是一个sqlsession,非事务中，  
两次查询用的是不同的sqlsession。配置正确的情况下，失效的原因一般都是没有在同一个session中。    


# MyBatis二级缓存的使用？
二级缓存是针对Mapper的namespace的，同namespace的Mapper中不同sqlsession可以获取到缓存，但发生更新操作的时候，会清除缓存。
在查询操作远远多于增删改操作的情况下可以使用二级缓存。因为任何增删改操作都将刷新二级缓存，对二级缓存的频繁刷新将降低系统性能。
最好在单表上使用二级缓存。

# 22.springmvc和spring-boot区别？
    SpringMVC是MVC框架,Spring Boot是快速开发基于Spring的应用.Spring Boot 通过stater的方式简化  
    整个Spring生态配置, SpringMVC, 对应的starter就是spring-boot-starter-web, 开发体验上来说,  
    没有很多xml配置,并内置了tomcat.
    
# 看过MyBatis源码吗，请说说它的工作流程？
1.加载配置文件。
2.创建会话工厂。
3.创建会话。
4.创建执行器。（可能会执行拦截器）
5.输入映射封装到sql,去数据库查询，返回结果集封装给应用。    
    

# 23.Spring MVC完整工作流程
1. 用户发起请求到前端控制器（DispatcherServlet），该控制器会过滤出哪些请求可以访问Servlet、哪些不能访问。就是url-pattern的作用，并且会加载springmvc.xml配置文件。
2. 前端控制器会找到处理器映射器（HandlerMapping），通过HandlerMapping完成url到controller映射的组件，简单来说，就是将在springmvc.xml中配置的或者注解的url与对应的处理类找到并进行存储，用map<url,handler>这样的方式来存储。
3. HandlerMapping有了映射关系，并且找到url对应的处理器，HandlerMapping就会将其处理器（Handler）返回，在返回前，会加上很多拦截器。
4. DispatcherServlet拿到Handler后，找到HandlerAdapter（处理器适配器），通过它来访问处理器，并执行处理器。
5. 执行处理器
6. 处理器会返回一个ModelAndView对象给HandlerAdapter
7. 通过HandlerAdapter将ModelAndView对象返回给前端控制器(DispatcherServlet)
8. 前端控制器请求视图解析器(ViewResolver)去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)，其实就是将ModelAndView对象中存放视图的名称进行查找，找到对应的页面形成视图对象
9. 返回视图对象到前端控制器。
10. 视图渲染，就是将ModelAndView对象中的数据放到request域中，用来让页面加载数据的。
11. 通过第8步，通过名称找到了对应的页面，通过第10步，request域中有了所需要的数据，那么就能够进行视图渲染了。最后将其返回即可。


# SpringMVC如何处理JSON数据？
在xml中配置转换Json的类，运行时就会调用这个类进行转换。


# SpringMVC常见注解有哪些？
@Controller 、@RequestMapping、@Autowired、@Resource、@PathVariable、@RequestParam、
@ModelAttribute、@SessionAttribute

# 24.Hibernate继承映射策略
继承关系的映射策略有三种：  
- 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。
- 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。
- 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。


# SpringMVC拦截器原理，如何自定义拦截器？
跟web.xml的过滤器链差不多。通过统一的Servlet入口进入，针对的是Controller，在Controller前后做一些增强性的操作。



# SpringMVC如何将请求映射定位到方法上面？结合源码阐述？
SpringMVC根据请求的路径，在一个类似于Map的结构中，以路径为键值找到对应的Controller。
