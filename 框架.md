# 1.说一下IOC和AOP？
IOC是依赖反转，通过依赖注入DI实现IOC。主要思想是面向抽象编程而不是面向具体实现编程。反转的意思是从依赖具体  
实现变为依赖抽象。
AOP是面向切面编程，通过代理对代码无侵入的添加功能，实现切面编程。比如事务、日志等模块。
代理机制主要有jdk提供的动态代理和cglib提供的字节码动态代码。


# 2.Spring中Bean的生命周期。
1. 首先这个bean在进行开始实例化的时候会先进行调用该类的构造函数，默认是单例的
2. 然后去注入属性中的bean
3. 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
4. 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
5. 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
6. 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
7. 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
8. 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
9. 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
10. 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；

# 3.Spring中注解Autowired和Resource的区别？ 

共同点:  
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。  
不同点 :  
（1）@Autowired 为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;  
只按照byType注入。 @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，  
可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。  
（2）@Resource 默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：  
name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，  
则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射  
机制使用byName自动注入策略。如果按name找不到对应的bean的话回退到ByType的自动注入策略。

# 4.@Controller和@RestController的区别？ 
@Controller

    方法的返回值。默认是视图页面的跳转路径。
    如果想返回json对象，必须在方法的上面加@ResponseBody

@RestController

    方法返回值，默认是json对象，也就是相当于@Controller里面的方法上添加了@ResponseBody
    如果方法返回值需要跳转视图页面的话，那么方法的返回类型必须是View 或者ModelAndView.
    
    
# 5.依赖注入的方式有哪几种？

1. set方法注入
2. 构造器注入
3. 注解注入

# 6.Spring中IOC的原理？
1. 加载并且保存Spring配置文件路径信息然后保存到configLocation中
2. 刷新Spring上下文环境
3. 创建并且载入DefaultListableBeanFactory（即BeanFactory）
4. 根据DefaultListableBeanFactory创建XMLBeanDefinitionReader，用于后面读取xml配置文件信息
5. 创建BeanDefinitionDelegate代理类，用于解析xml配置信息
6. 解析xml中配置的<import>、<bean>、<beans>、<alias>等不同的标签信息，以便于可以使用不同的解析器进行解析
7. 通过XMLBeanDefinitionReader结合location路径信息读取Resources资源信息
8. 使用BeanDefinitionDelegate代理类解析Bean元素并且依次进行实例化操作，实例化完毕之后将Bean信息注册（put）  
   到BeanDefinitionMap中以便于可以下次继续使用
    
# 7.Spring中BeanFactory和ApplicationContext的区别？
BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。

BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。  
而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。

ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。

加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建  
所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是启动时间会比较耗时。


# 8.什么是IoC和DI？DI是如何实现的？ 
IOC是控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，遵循了依赖倒置的原则。可以用来减低计算机代码  
之间的耦合度。控制指的是对实现类的控制,反转指的是这种控制权从调用类中移除,交给第三方（容器）决定。
而控制反转其中最常见实现方式叫做依赖注入（Dependency Injection，简称DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有  
对象的外界实体，将其所依赖的对象的引用传递(注入)给它。
还有一种ioc的实现方式叫“依赖查找”（Dependency Lookup），但Martin Fowler认为DI的实现方式更灵活解耦。


# 9.请问Spring中Bean的作用域有哪些？
1. singleton为默认值，IOC容器中仅存在一个Bean实例，Bean都以单例模式存在
2. prototype，在每次请求获取Bean的时候，都会创建一个新的实例，它在容器初始化的时候不会创建实例，采用的是延迟加载的形式注入
Bean，当你使用的时候，才会进行实例化，每次实例化获取的对象都不是同一个 就像BeanFactory的实例化模式 实例不唯一
3. request，在每一次http请求时会创建一个实例，该实例仅在当前http request有效
4. session，在每一次http请求时会创建一个实例，该实例仅在当前http session有效
5. globalSession，全局Session，仅供基于Porlet的web环境进行使用。（很少使用到）

# 10.请谈一谈Spring中自动装配的方式有哪些？

1. no：不进行自动装配，手动设置Bean的依赖关系。
2. byName：根据Bean的名字进行自动装配。
3. byType：根据Bean的类型进行自动装配。
4. constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
5. autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配


# 11.aop的应用场景？ 
1. 事务
2. 权限
3. 日志
4. 缓存
5. 性能统计


# 12.AOP的原理？


```
Spring AOP中的代理使用的默认策略是：
如果目标对象实现了接口，则默认采用JDK动态代理
如果目标对象没有实现接口，则采用CgLib进行动态代理
如果目标对象实现了接口，且强制CgLib代理，则采用CgLib进行动态代理
```


