# 1.说一下IOC和AOP？
IOC是依赖反转，通过依赖注入DI实现IOC。主要思想是面向抽象编程而不是面向具体实现编程。反转的意思是从依赖具体  
实现变为依赖抽象。
AOP是面向切面编程，通过代理对代码无侵入的添加功能，实现切面编程。比如事务、日志等模块。
代理机制主要有jdk提供的动态代理和cglib提供的字节码动态代码。


# 2.Spring中Bean的生命周期。
1. 首先这个bean在进行开始实例化的时候会先进行调用该类的构造函数，默认是单例的
2. 然后去注入属性中的bean
3. 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
4. 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
5. 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
6. 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
7. 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
8. 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
9. 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
10. 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；

# 3.Spring中注解Autowired和Resource的区别？ 

共同点:  
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。  
不同点 :  
（1）@Autowired 为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;  
只按照byType注入。 @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，  
可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。  
（2）@Resource 默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：  
name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，  
则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射  
机制使用byName自动注入策略。如果按name找不到对应的bean的话回退到ByType的自动注入策略。

# 4.@Controller和@RestController的区别？ 
@Controller

    方法的返回值。默认是视图页面的跳转路径。
    如果想返回json对象，必须在方法的上面加@ResponseBody

@RestController

    方法返回值，默认是json对象，也就是相当于@Controller里面的方法上添加了@ResponseBody
    如果方法返回值需要跳转视图页面的话，那么方法的返回类型必须是View 或者ModelAndView.
    
    
# 5.依赖注入的方式有哪几种？

1. set方法注入
2. 构造器注入
3. 注解注入

# 6.
