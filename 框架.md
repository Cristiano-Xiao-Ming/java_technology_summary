# 1.说一下IOC和AOP？
IOC是依赖反转，通过依赖注入DI实现IOC。主要思想是面向抽象编程而不是面向具体实现编程。反转的意思是从依赖具体  
实现变为依赖抽象。
AOP是面向切面编程，通过代理对代码无侵入的添加功能，实现切面编程。比如事务、日志等模块。
代理机制主要有jdk提供的动态代理和cglib提供的字节码动态代码。


# 2.Spring中Bean的生命周期。
1. 首先这个bean在进行开始实例化的时候会先进行调用该类的构造函数，默认是单例的
2. 然后去注入属性中的bean
3. 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
4. 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
5. 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
6. 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
7. 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
8. 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
9. 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
10. 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；

# 3.Spring中注解Autowired和Resource的区别？ 

共同点:  
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。  
不同点 :  
（1）@Autowired 为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;  
只按照byType注入。 @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，  
可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。  
（2）@Resource 默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：  
name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，  
则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射  
机制使用byName自动注入策略。如果按name找不到对应的bean的话回退到ByType的自动注入策略。

# 4.@Controller和@RestController的区别？ 
@Controller

    方法的返回值。默认是视图页面的跳转路径。
    如果想返回json对象，必须在方法的上面加@ResponseBody

@RestController

    方法返回值，默认是json对象，也就是相当于@Controller里面的方法上添加了@ResponseBody
    如果方法返回值需要跳转视图页面的话，那么方法的返回类型必须是View 或者ModelAndView.
    
    
# 5.依赖注入的方式有哪几种？

1. set方法注入
2. 构造器注入
3. 注解注入

# 6.Spring中IOC的原理？
1. 加载并且保存Spring配置文件路径信息然后保存到configLocation中
2. 刷新Spring上下文环境
3. 创建并且载入DefaultListableBeanFactory（即BeanFactory）
4. 根据DefaultListableBeanFactory创建XMLBeanDefinitionReader，用于后面读取xml配置文件信息
5. 创建BeanDefinitionDelegate代理类，用于解析xml配置信息
6. 解析xml中配置的<import>、<bean>、<beans>、<alias>等不同的标签信息，以便于可以使用不同的解析器进行解析
7. 通过XMLBeanDefinitionReader结合location路径信息读取Resources资源信息
8. 使用BeanDefinitionDelegate代理类解析Bean元素并且依次进行实例化操作，实例化完毕之后将Bean信息注册（put）  
   到BeanDefinitionMap中以便于可以下次继续使用
    
# 7.Spring中BeanFactory和ApplicationContext的区别？
BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。

BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。  
而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。

ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。

加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建  
所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是启动时间会比较耗时。


# 8.什么是IoC和DI？DI是如何实现的？ 
IOC是控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，遵循了依赖倒置的原则。可以用来减低计算机代码  
之间的耦合度。控制指的是对实现类的控制,反转指的是这种控制权从调用类中移除,交给第三方（容器）决定。
而控制反转其中最常见实现方式叫做依赖注入（Dependency Injection，简称DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有  
对象的外界实体，将其所依赖的对象的引用传递(注入)给它。
还有一种ioc的实现方式叫“依赖查找”（Dependency Lookup），但Martin Fowler认为DI的实现方式更灵活解耦。


# 9.请问Spring中Bean的作用域有哪些？
1. singleton为默认值，IOC容器中仅存在一个Bean实例，Bean都以单例模式存在
2. prototype，在每次请求获取Bean的时候，都会创建一个新的实例，它在容器初始化的时候不会创建实例，采用的是延迟加载的形式注入
Bean，当你使用的时候，才会进行实例化，每次实例化获取的对象都不是同一个 就像BeanFactory的实例化模式 实例不唯一
3. request，在每一次http请求时会创建一个实例，该实例仅在当前http request有效
4. session，在每一次http请求时会创建一个实例，该实例仅在当前http session有效
5. globalSession，全局Session，仅供基于Porlet的web环境进行使用。（很少使用到）

# 10.请谈一谈Spring中自动装配的方式有哪些？

1. no：不进行自动装配，手动设置Bean的依赖关系。
2. byName：根据Bean的名字进行自动装配。
3. byType：根据Bean的类型进行自动装配。
4. constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
5. autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配


# 11.aop的应用场景？ 
1. 事务
2. 权限
3. 日志
4. 缓存
5. 性能统计


# 12.AOP的原理？


```
Spring AOP中的代理使用的默认策略是：
如果目标对象实现了接口，则默认采用JDK动态代理
如果目标对象没有实现接口，则采用CgLib进行动态代理
如果目标对象实现了接口，且强制CgLib代理，则采用CgLib进行动态代理
```


# 13.你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？ 


- 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。
- 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。
- 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。
说明： Advice在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。
- 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。
- 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：1.编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；2.装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；3.运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。
- 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。

# 14.请问Spring支持的事务管理类型有哪些？

1. 声明式事务
本质使用AOP，将业务和事务管理分离，降低耦合度和提高事务的复用能力。声明式事务可以通过注解@Transactional和配置来管理事务，  
操作简单。

2. 编程式事务
编程式事务是在代码中使用TransactionTemplate进行硬编码，与业务的耦合度高，难以复用。但控制事务的范围比较灵活。


# 15.Spring的优点？
- 降低了组件之间的耦合性，实现了软件各层之间的解耦
- 可以使用容易提供的众多服务，如事务管理，消息服务等
- 容器提供单例模式支持
- 容器提供了 AOP 技术，利用它很容易实现如权限拦截，运行期监控等功能
- 容器提供了众多的辅助类，能加快应用的开发
- spring 对于主流的应用框架提供了集成支持，如 hibernate，JPA，Struts 等
- spring 属于低侵入式设计，代码的污染极低
- 独立于各种应用服务器
- spring 的 DI 机制降低了业务对象替换的复杂性
- Spring 的高度开放性，并不强制应用完全依赖于 Spring，开发者可以自由选择 spring 的部分或全部

# 16.请阐述一下Hibernate实体对象的三种状态是什么？以及对应的转换关系是什么？？
瞬时态，持久态和游离态。
瞬时态没有id，对象刚new出来的时候处于瞬时态。
持久态有id（与数据库中的主键关联）,通过get()或者load()方法获取的对象处于持久态。
游离态:持久态的对象脱离了session的管理变成游离态，处于游离态的对象如果不被其它对象引用则会被垃圾回收机制回收。
转化：
瞬时转持久：Session对象的save()或saveOrUpdate()方法保存对象
持久转瞬时，调用delete()方法
持久转游离：调用Session对象的clear()/close()/evict()
游离转瞬时：调用delete()方法
游离转持久: 调用update()或者saveOrUpdate() 

# 17.Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？
SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。  
SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。  
Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。  
Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。  
Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal  
将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的  
getCurrentSession()方法就可以做到。


# 18.Hibernate中Session的load和get方法的区别是什么？
1. 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
2. get方法直接返回实体类对象，load方法返回实体类对象的代理(如果lazy='true' ，就使用延迟加载，返回的是代理，不是真实对象)。
3. 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，  
直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对  
二级缓存只写不读，它也是可以访问二级缓存的。



