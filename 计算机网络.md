# TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？
从上到下依次是HTTP（应用层）、TCP（传输层）、IP（网络层）。 

# 讲一下TCP的连接和释放连接。
三次握手建立连接：  
1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN  
（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位  
SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）  
状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认  
号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步  
收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，  
此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是  
如果不携带数据则不消耗序号。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。


四次挥手释放连接：
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于  
前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。  
TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务  
端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，  
这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个  
状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送  
连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，  
服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）  
状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，  
此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长  
报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。  
可以看到，服务器结束TCP连接的时间要比客户端早一些。


# tcp和udp的应用场景？
为了实现TCP网络通信的可靠性，增加校验和、序号标识、滑动窗口、确认应答、拥塞控制等复杂的机制，建立了  
繁琐的握手过程，增加了TCP对系统资源的消耗;TCP的重传机制、顺序控制机制等对数据传输有一定延时影响，降  
低了传输效率。TCP适合对传输效率要求低，但准确率要求高的应用场景，比如万维网(HTTP)、文件传输(FTP)、  
电子邮件(SMTP)等。

UDP是无连接的，不可靠传输，尽最大努力交付数据，协议简单、资源要求少、传输速度快、实时性高的特点，适用  
于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(DNS)、流媒体传输，语音传输等。

# tcp是如何实现可靠传输的？
TCP协议主要通过检验和、序列号、确认应答（ACK）、重发控制、连接管理、窗口控制等实现可靠性连接。


# tcp为什么要建立连接？
tcp是提供可靠性连接的，只有支持端到端的连接，才能进行可靠性传输，连接的主要功能在于记录两个端口间  
的通信状态，不连接则无法记录两个端口通信的状态，则无法知道丢失了哪个数据包，重复收到了哪个数据包，  
也无法确保数据包之间的到达顺序，还有很多增加可靠性的功能都无法应用。


# 输入一个url，到渲染出页面一共经历了哪些过程？


    1.首先浏览器开启一个线程来处理这个请求，对URL分析判断，如果是http协议就按照Web方式来处理；
    2.其次浏览器会对URL进行解析，一般包括（协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等），
    然后开启网络线程发出一个完整到http请求；
    3.当然一般我们输入的URL是服务器域名，这时就需要DNS通过域名查询得到对应的IP；
    3.DNS首先会查看浏览器DNS缓存，没有就查询计算机本地DNS缓存，还没有就询问递归式DNS服务器（即网络提供商，一般
    这个服务器都会有自己的缓存，所以IP查询一般在这里完成），如果没有缓存，那就需要通过根域名和TLD域名服务器指到
    对应的权威DNS服务器找回记录，并缓存到递归式服务器，然后递归服务器在将记录返回给本地。
    5.有了IP地址，此时网络层便会通过IP地址寻的对应服务器的物理地址
    6.寻得服务器地址，客户端在网络传输层便可以和服务器通过三次握手建立tcpip连接
    7.连接建立后网络数据链路层将数据包装成帧；
    8.最后物理层利用物理介质进行传输；
    9.到了服务器，就会通过相反的方式将数据一层一层的还原回去；
    10.请求到了后台服务器，一般会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的http报文
    11.验证通过后，就会进入后台代码，此时程序收到请求，然后执行对应的操作（如查询数据库等）；
    12.如果浏览器访问过，且缓存上有对应的资源，便会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存；
    13.前端浏览器接收到响应成功的报文后便开始下载网页

    14.下载完的网页将被交给浏览器内核（渲染进程）进行处理：
        （1）根据顶部定义的DTD类型进行对应的解析方式；
        （2）渲染进程内部是多线程的，网页的解析将会被交给内部的GUI渲染线程处理；
        （3）首先渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流；
        （4）再通过词法分析器将字符流解释成词语；
        （5）之后经过语法分析器根据词语构建成节点；最后通过这些节点组建一个DOM树；
        （6）这个过程中，如果遇到的DOM节点是JavaScript代码，就会调用JavaScript引擎对JavaScript代码进行解释执行，
        （7）此时由JavaScript引擎和GUI渲染线程的互斥，GUI渲染线程就会被挂起，渲染过程停止；如果JavaScript代码的运
        行中对DOM树进行了修改，那么DOM的构建需要从新开始；
        （8）如果节点需要依赖其他资源，如（图片，CSS等），便会调用网络模块的资源加载器来加载它们，但它们是异步的，
        不会阻塞当前DOM树的构建；
        （9）如果遇到的是JavaScript资源URL（没有标记异步），则需要停止当前DOM的构建，直到JavaScript的资源加载并
        被JavaScript引擎执行后才继续构建DOM；
        （10）对于CSS，CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树；
        然后合并CSS规则树和DOM树，生成render渲染树；
        （11）最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程进行显示。

# http和https的区别？
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，  
比http协议安全。

# http的请求方式有哪些方式，应答码502和504有什么区别？

1. opions 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许客户端查看服务器性能）
2. Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）
3. Post 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改
4. Put 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）
5. Head 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的  
响应中没有具体内容，用于获取报头）
6. Delete 请求服务器删除request-URL所标示的资源（请求服务器删除页面）
7. Trace 回显服务器收到的请求，用于测试和诊断
8. Connect HTTP/1.1协议中能够将连接改为管道方式的代理服务器

502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 
504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识  
出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 


# http1.0和http1.1有什么区别？

1. 默认支持长连接;
2. 带宽优化，并支持断点续传；
3. 新增例如ETag，If-None-Match等更多的缓存控制策略;
4. Host头域;
5. 新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示  
服务器上的某个资源被永久性的删除；


# ssl四次握手的过程？

1. 客户端发起HTTPS请求

2. 服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端  
验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。一套证书其实就是一对公钥和私钥。公钥给别人加  
密使用，私钥给自己解密使用。

3. 传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。

4. 客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会  
弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。

5. 传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这  
个随机值来进行加密解密了。

6. 服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，  
将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，  
所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. 传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8. 客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。
