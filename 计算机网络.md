- 标★号为重要知识点

## TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？
从上到下依次是HTTP（应用层）、TCP（传输层）、IP（网络层）。 

http协议：
解决web应用的传输规则。

tcp协议:
主要解决网络的可靠传输。

ip协议：
IP协议的任务是对数据报进行相应的寻址和路由选择，并从一个网络转发到另一个网络。
IP协议的另一项工作是分割和重编在传输层被分割的数据包。
IP协议提供尽最大努力投递(Best-effort Delivery)的传输服务，是不可靠无连接的数据报服务。



## ★讲一下TCP的连接和释放连接。

三次握手建立连接：  

1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，  
Client进入SYN_SENT状态，等待Server确认。

2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，  
ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，  
并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server  
进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 


四次挥手释放连接：

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），  
Server进入CLOSE_WAIT状态。
3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，  
Server进入CLOSED状态，完成四次挥手。

## ★为什么要三次握手四次挥手？
 
###### 为什么需要三次握手？

防止已失效的连接请求又传送到服务器端，因而产生错误。通俗的说法如果两次握手的话，就是A发送一个分组给B,结果在网络中滞留了。结果又发了一个分组给B,B收到分组，回复A。开始建立连接传送数据。传好了之后。之前在网络滞留的分组又到了B，结果又建立了连接。  

比较严谨的解释是：为了实现可靠数据传输， TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。  




###### 为什么需要四次挥手？

因为TCP有个半关闭状态，假设A.B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。



## tcp和udp的应用场景？
TCP为了实现TCP网络通信的可靠性，增加校验和、序号标识、滑动窗口、确认应答、拥塞控制等复杂的机制，建立了
繁琐的握手过程，增加了TCP对系统资源的消耗;TCP的重传机制、顺序控制机制等对数据传输有一定延时影响，降
低了传输效率。TCP适合对传输效率要求低，但准确率要求高的应用场景，比如万维网(HTTP)、文件传输(FTP)、
电子邮件(SMTP)等。
  
  
UDP是无连接的，不可靠传输，尽最大努力交付数据，协议简单、资源要求少、传输速度快、实时性高的特点，适用
于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(DNS)、流媒体传输，语音传输等。  

但其实很有语音视频应用还是有使用tcp。

## ★tcp是如何实现可靠传输的？
TCP协议主要通过检验和、序列号、确认应答（ACK）、重发控制、连接管理、窗口控制等实现可靠性连接。


## tcp为什么要建立连接？
tcp是提供可靠性连接的，只有支持端到端的连接，才能进行可靠性传输，连接的主要功能在于记录两个端口间  
的通信状态，不连接则无法记录两个端口通信的状态，则无法知道丢失了哪个数据包，重复收到了哪个数据包，  
也无法确保数据包之间的到达顺序，还有很多增加可靠性的功能都无法应用。


## ★输入一个url，到渲染出页面一共经历了哪些过程？


    1.首先浏览器开启一个线程来处理这个请求，对URL分析判断，如果是http协议就按照Web方式来处理；
    2.其次浏览器会对URL进行解析，一般包括（协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等），
    然后开启网络线程发出一个完整到http请求；
    3.当然一般我们输入的URL是服务器域名，这时就需要DNS通过域名查询得到对应的IP；
    3.DNS首先会查看浏览器DNS缓存，没有就查询计算机本地DNS缓存，还没有就询问递归式DNS服务器（即网络提供商，一般
    这个服务器都会有自己的缓存，所以IP查询一般在这里完成），如果没有缓存，那就需要通过根域名和TLD域名服务器指到
    对应的权威DNS服务器找回记录，并缓存到递归式服务器，然后递归服务器在将记录返回给本地。
    5.有了IP地址，此时网络层便会通过IP地址寻的对应服务器的物理地址
    6.寻得服务器地址，客户端在网络传输层便可以和服务器通过三次握手建立tcpip连接
    7.连接建立后网络数据链路层将数据包装成帧；
    8.最后物理层利用物理介质进行传输；
    9.到了服务器，就会通过相反的方式将数据一层一层的还原回去；
    10.请求到了后台服务器，一般会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的http报文
    11.验证通过后，就会进入后台代码，此时程序收到请求，然后执行对应的操作（如查询数据库等）；
    12.如果浏览器访问过，且缓存上有对应的资源，便会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存；
    13.前端浏览器接收到响应成功的报文后便开始下载网页

    14.下载完的网页将被交给浏览器内核（渲染进程）进行处理：
        （1）根据顶部定义的DTD类型进行对应的解析方式；
        （2）渲染进程内部是多线程的，网页的解析将会被交给内部的GUI渲染线程处理；
        （3）首先渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流；
        （4）再通过词法分析器将字符流解释成词语；
        （5）之后经过语法分析器根据词语构建成节点；最后通过这些节点组建一个DOM树；
        （6）这个过程中，如果遇到的DOM节点是JavaScript代码，就会调用JavaScript引擎对JavaScript代码进行解释执行，
        （7）此时由JavaScript引擎和GUI渲染线程的互斥，GUI渲染线程就会被挂起，渲染过程停止；如果JavaScript代码的运
        行中对DOM树进行了修改，那么DOM的构建需要从新开始；
        （8）如果节点需要依赖其他资源，如（图片，CSS等），便会调用网络模块的资源加载器来加载它们，但它们是异步的，
        不会阻塞当前DOM树的构建；
        （9）如果遇到的是JavaScript资源URL（没有标记异步），则需要停止当前DOM的构建，直到JavaScript的资源加载并
        被JavaScript引擎执行后才继续构建DOM；
        （10）对于CSS，CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树；
        然后合并CSS规则树和DOM树，生成render渲染树；
        （11）最后对render树进行布局和绘制，并将结果通过IO线程传递给Browser控制进程进行显示。

参考网址：https://blog.csdn.net/synsdeng/article/details/77096451

## ★http和https的区别？
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，
比http协议安全。

# http的无状态是什么意思？请求方式有哪些方式，应答码502和504有什么区别？可以定义新的请求方式吗？

无状态指的是每次请求都是独立的，服务器无法感知下一次请求和当前请求之间是存在关联的。

1. opions 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许客户端查看服务器性能）
2. Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）
3. Post 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改
4. Put 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）
5. Head 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的
响应中没有具体内容，用于获取报头）
6. Delete 请求服务器删除request-URL所标示的资源（请求服务器删除页面）
7. Trace 回显服务器收到的请求，用于测试和诊断
8. Connect HTTP/1.1协议中能够将连接改为管道方式的代理服务器

- 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 
- 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识
出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 


可以定义新的请求方式，但需要客户端和服务端一起配合。

## http1.0和http1.1有什么区别？

1. 默认支持长连接;
2. 带宽优化，并支持断点续传；
3. 新增例如ETag，If-None-Match等更多的缓存控制策略;
4. Host头域;
5. 新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示  
服务器上的某个资源被永久性的删除；




## ★ssl四次握手的过程？

1. 客户端发起HTTPS请求

2. 服务端的配置

- 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端
验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。一套证书其实就是一对公钥和私钥。公钥给别人加
密使用，私钥给自己解密使用。

3. 传送证书
- 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。

4. 客户端解析证书
- 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会
弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。

5. 传送加密信息
- 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这
个随机值来进行加密解密了。

6. 服务段解密信息
- 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，
将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，
所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. 传输加密后的信息
- 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8. 客户端解密信息
- 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。

## HTTPS工作流程？
1. 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了
2. 服务器从中选出一套加密算法和hash算法以及自己的身份信息(地址等)以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构
3. 客户端收到网站的证书之后要做下面的事情： 
        - 验证证书的合法性
        - 如果验证通过证书，浏览器会生成一串随机数作为密钥K，并用证书中的公钥进行加密
        - 用约定好的hash算法计算握手消息，然后用生成的密钥K进行加密，然后一起发送给服务器
4. 服务器接收到客户端传送来的信息，要求下面的事情： 
        - 用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致
        - 使用密钥加密消息，回送  
        
如果计算法hash值一致，握手成功

## 304状态码的意思？

304状态码是告诉浏览器可以从缓存中获取所请求的资源。  

当浏览器请求某一文件时，发现自己缓存的文件有Last-Modified，就会在httpRequest里面添加消息头If-Modified-Since
和If-Non-Match，服务器在收到request时，和服务器本地文件对比，如果没有更新，则仅仅返回一个响应头Head
（状态码304，而没有响应体），客户端在收到这个响应时，就会从本地缓存加载请求的资源。

## 什么是arp协议？什么是arp攻击？
- arp协议是地址解析协议，用于将IP地址转换为mac地址。 
- arp攻击使用别人的IP地址和自己的MAC地址向目标主机发送ARP包  
- 欺骗成功后，目标发给别人IP地址的数据，都会发到你对应的MAC地址的设备上。 


## 什么是icmp协议？
ICMP的全称是 Internet Control Message Protocol 。从技术角度来说，ICMP就是一个“错误侦测与回报机制”，
其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：
- 侦测远端主机是否存在
- 建立及维护路由资料
- 重导数据传送路径
- 数据流量控制


## 路由器和交换机的区别？  

区别一：  

路由器可以给局域网自动分配IP，虚拟拨号。交换机则只是用来分配网络数据的。
区别二：  

- 路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。
- 交换机可以把很多主机连起来，这些主机对外各有各的IP。
区别三：  

- 交换机工作在数据链路层，根据MAC地址寻址，不能处理TCP/IP协议。
- 路由器工作在网络层，根据IP地址寻址，可以处理TCP/IP协议。
区别四：  

- 路由器提供防火墙服务，交换机不能提供该功能。

## dns的寻址过程？
1. 浏览器缓存：浏览器会按照一定的频率缓存DNS记录。
2. 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。
3. 路由缓存：路由器也有DNS缓存。
4. ISP的DNS服务器：ISP是互联网服务提供商(Internet Service Provider)的简称，
ISP有专门的DNS服务器应对DNS查询请求。
5. 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问  
根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）



## ★nginx反向代理的优点和缺点
优点：
1. 工作在网络7层之上，可针对http应用做一些分流的策略，如针对域名、目录结构，它的正规规则比HAProxy  
更为强大和灵活，所以，目前为止广泛流行。
2. Nginx对网络稳定性的依赖非常小，理论上能ping通就能进行负载功能。
3. Nginx安装与配置比较简单，测试也比较方便，基本能把错误日志打印出来。
4. 可以承担高负载压力且稳定，硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS小。
5. Nginx可以通过端口检测到服务器内部的故障，如根据服务器处理网页返回的状态码、超时等，并会把返回错误
的请求重新提交到另一个节点。
6. 不仅仅是优秀的负载均衡器/反向代理软件，同时也是强大的Web应用服务器。LNMP也是近些年非常流行的Web架构，
在高流量环境中稳定性也很好。
7. 可作为中层反向代理使用。
8. 可作为静态网页和图片服务器。
9. Nginx社区活跃，第三方模块非常多。
缺点：
1. 适应范围较小，仅能支持http、https、Email协议。
2. 对后端服务器的健康检查，只支持通过端口检测，不支持url来检测。比如用户正在上传一个文件，而处理该上传
的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个
很大的文件或者很重要的文件的话，用户可能会因此而不满。
3. 不支持Session的直接保持，但能通过ip_hash来解决，对Big request header的支持不是很好

        可做负载均衡以及静态服务器


# ★Http1.0和Http1.1的区别是什么？
HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。  
HTTP1.1支持只发header信息，可携带host域。
btw,HTTP1.1是半双工，HTTP2.0是全双工。

一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。  


显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含 Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。  


为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP 1.1协议的客户机与服务器的信息交换过程。

可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1 还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0 的功能。例如，由于 HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1 的持续连接，也需要增加新的请求头来帮助实现，例如，Connection 请求头的值为Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为close 时，客户端通知服务器返回本次请求结果后关闭连接。 HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。 

## socket通信模型的使用，AIO和NIO。
NIO是同步非阻塞的，其实是轮询去观测哪个通道就绪。
AIO是异步非阻塞的，使得数据就绪之后可以回调函数，实现真正的异步，底层依赖的是操作系统的IO模型。


## NIO的实现原理
通过Buffer，Channel，Selector三者。  数据从Buffer读到Channel，从Channel读到Buffer，面向缓冲区实现，
并且利用Selector注册多个线程，观测哪个线程所属通道Buffer是否就绪。从而实现同步非阻塞。


## ★同步和异步，阻塞和非阻塞。
- 同步和异步是从方法调用的角度：  
- 同步指的是必须等待方法完全执行结束才返回。
- 异步指的是方法立即返回，但执行结果还没计算出来。

- 阻塞和非阻塞是从线程的角度：
- 阻塞指的是线程呆在原地等待。
- 非阻塞指的是线程不呆在原地等待，先去做别的事，然后过来询问方法是否执行完成。




## 说说http,tcp,udp之间关系和区别。

UDP:  

1. 无连接
2. 不可靠传输，不使用流量控制和拥塞控制
3. 支持一对一，一对多，多对一和多对多交互通信
4. 面向报文
5. 首部开销小，仅8字节,
6. 适用于实时应用（IP电话、视频会议、直播等）
TCP:  

1. 面向连接
2. 可靠传输，使用流量控制和拥塞控制
3. 只能是一对一通信
4. 面向字节流
5. 首部最小20字节，最大60字节
6. 适用于要求可靠传输的应用，例如文件传输



## ★tcp的拥塞机制
我们知道TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。
首先需要了解一个概念，为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。
拥塞控制主要是四个算法：  

1. 慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。  
```
连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
每当收到一个ACK，cwnd++; 呈线性上升
每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
```
2. 拥塞避免：当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。
```
每当收到一个ACK，cwnd = cwnd + 1/cwnd
每当过了一个RTT，cwnd = cwnd + 1
拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：
等到RTO超时，重传数据包
sshthresh = cwnd /2
cwnd 重置为 1
```
3. 进入慢启动过程
```
在收到3个duplicate ACK时就开启重传，而不用等到RTO超时
sshthresh = cwnd = cwnd /2
进入快速恢复算法——Fast Recovery
```
4. 快速恢复：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。
```
cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）
重传Duplicated ACKs指定的数据包
如果再收到 duplicated Acks，那么cwnd = cwnd +1
如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。
```

原文链接：https://blog.csdn.net/shuxnhs/article/details/80644531





## head各个特点和区别
向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

## DoS，DDoS，DRDoS攻击分别是什么？

- DoS是Denial of Service的简写就是拒绝服务。

- DDoS就是Distributed Denial of Service的简写就是分布式拒绝服务。

- DRDoS就是Distributed Reflection Denial of Service的简写,分布反射式拒绝服务。

- DoS、DDos以及DRDoS攻击手段和防范措施




## 说一下http/2.0

- Http/2采用二进制格式而不是文本

- Http/2是完全多路复用的，而非有序并阻塞的。

- Http/2使用报头压缩

- Http/2让服务器可以将响应主动推送到客户端缓存中。



## socket通信，以及长连接，分包，连接异常断开的处理。
长连接：通过心跳
分包粘包：通过定义消息头部（长度）、或者自定义结束符
连接异常断开：.待解决

## ★TCP/IP如何保证可靠性，数据包有哪些数据组成，TCP头的结构。

校验和：  

- 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 

确认应答+序列号：  

- TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 

超时重传：  

- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 

流量控制：  

- TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
- 接收方有即时窗口（滑动窗口），随ACK报文发送

拥塞控制：  

- 当网络拥塞时，减少数据的发送。
- 发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小的窗口值进行发送
- 慢启动、拥塞避免、拥塞发送、快速恢复

报文格式：  


1. 源端口号（Source Port）
- 长度为16位，指明发送数据的进程。
2. 目的端口号（Destination Port）
- 长度为16位，指明目的主机接收数据的进程。
3. 序号（Sequence Number）
- 也称为序列号，长度为32位，序号用来标识从TCP发送端向接入端发送的数据字节流进行编号，可以理解成对字节流的计数。
4. 确认号（Acknowledgement Number）
- 长度为32位，确认号包含发送确认的一端所期望收到的下一个序号。确认号只有在ACK标志为1时才有效。
5. 首部长度
- 长度为4位，用于表示TCP报文首部的长度。用4位（bit）表示，十进制值就是[0,15]，一个TCP报文前20个字节是必有的，后40个字节根据情况可能有可能没有。如果TCP报文首部是20个字节，则该位应是20/4=5。
6. 保留位（Reserved）
- 长度为6位，必须是0，它是为将来定义新用途保留的。
7. 标志（Code Bits）
- 长度为6位，在TCP报文中不管是握手还是挥手还是传数据等，这6位标志都很重要。6位从左到右依次为：

- URG：紧急标志位，说明紧急指针有效；
- ACK：确认标志位，多数情况下空，说明确认序号有效；
- PSH：推标志位，置位时表示接收方应立即请求将报文交给应用层；
- RST：复位标志，用于重建一个已经混乱的连接；
- SYN：同步标志，该标志仅在三次握手建立TCP连接时有效
- FIN：结束标志，带该标志位的数据包用于结束一个TCP会话。
8. 窗口大小（Window Size）
- 长度为16位，TCP流量控制由连接的每一端通过声明的窗口大小来提供。
9. 检验和（Checksum）
- 长度为16位，该字段覆盖整个TCP报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。
10. 紧急指针（Urgent Pointer）
- 长度为16位，指向数据中优先部分的最后一个字节，通知接收方紧急数据的长度，该字段在URG标志置位时有效。
11. 选项（Options）
- 长度为0-40B（字节），必须以4B为单位变化，必要时可以填充0。通常包含：最长报文大小（MaximumSegment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。
12. 数据

https://blog.51cto.com/lyhbwwk/2162568


## ★长连接与短连接
长连接：  

所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；   

短连接：  

短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；连接→数据传输→关闭连接；

应用场景：  

长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。  
 
而像WEB网站的http服务一般都用短链接（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好；

## ★关闭连接时，出现TIMEWAIT过多是由什么原因引起，是出现在主动断开方还是被动断开方。
出现在主动断开方，是由于TIMEWAIT需要等待2MS的时间才能关闭。

## ★TIME_WAIT和CLOSE_WAIT的区别
TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接

CLOSE_WAIT由于在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。
通常来讲，CLOSE_WAIT状态的持续时间应该很短，正如SYN_RCVD状态。但是在一些特殊情况下，就会出现连接长时间处于CLOSE_WAIT状态的情况。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。

## ★为什么断开连接要4次,如果握手只有两次，会出现什么问题？
四次握手是为了双方告诉对方，自己已经没有信息发送了。一方断开需要两次握手，两方加起来就是四次握手。如果总共只有两次握手的话，会导致服务方接收不到客户方剩余未发送完的信息。

## ★TCP第四次挥手为什么要等待2MSL？
主要是主动关闭方的 第三次握手和第四次握手。
如果不等待2MS的话，将收不到最后一个确认ACK。
主动方发送关闭报文段需要1MS，被动方发送确认也需要1MS，故需要2MS。    

以及报文混淆：  
如果Client（客户端）直接CLOSED（关闭），然后又再向Server（服务器端）发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。





## 如何避免浏览器缓存。
1、Cache-Control/Pragma这个HTTP Head字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP协议相关的缓存或代理服务器。
Cache-Control请求字段被各个浏览器支持得较好，而且它的优先级也比较高，它和其他一些请求字段（如Expires）同时出现时，Cache-Control会覆盖其他字段。Pragma字段的作用和Cache-Control有点类似，它也是在HTTP头中包含一个特殊的指令，使相关的服务器来遵守，最常用的就是Pragma:no-cache，它和Cache-Control:no-cache的作用是一样的。  

2、Expires
Expires通常的使用格式是Expires:Sat,25Feb201212:22:17GMT，后面跟着一个日期和时间，超过这个时间值后，缓存的内容将失效，也就是浏览器在发出请求之前检查这个页面的这个字段，看该页面是否已经过期了，过期了就重新向服务器发起请求。  

3、Last-Modified/EtagLast-Modified字段一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态（静态内容自动加上Last-Modified字段）或者动态的内容（如Servlet提供了一个getLastModified方法用于检查某个动态内容是否已经更新），通过这个最后修改时间可以判断当前请求的资源是否是最新的。一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Last-Modified:Sat,25Feb201212:55:04GMT，浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25Feb 201212:55:04GMT字段，询问当前缓存的页面是否是最新的，如果是最新的就返回304状态码，告诉浏览器是最新的，服务器也不会传输新的数据。  

4、与Last-Modified字段有类似功能的还有一个Etag字段，这个字段的作用是让服务端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前这个页面是否是最新的。这种方式比使用Last-Modified更加灵活，但是在后端的Web服务器有多台时比较难处理，因为每个Web服务器都要记住网站的所有资源，否则浏览器返回这个编号就没有意义了。
  
  
还可以在前端访问链接时，加入随机串，使得浏览器认为是一个新的连接访问，从而不读取缓存。

## 简述HTTP的报文格式。
请求报文：  

请求方法：  

- GET：请求获取Request——URL所标识的资源
- POST：在Request——URL所标识的资源后附加资源
- HEAD：请求获取由Request——URL所标识的资源的响应消息报头
- PUT：请求服务器存储一个资源，由Request——URL作为其标识
- DELETE：请求服务器删除由Request——URL所标识的资源
- TRACE：请求服务器回送收到的请求信息（用于测试和诊断）
- CONNECT：保留
- OPTIONS：请求查询服务器性能  

URL：  

- URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。

协议版本:  

- 格式为 HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0
请求头部:  

- Host：接受请求的服务器地址，可以是IP或者是域名
- User-Agent：发送请求的应用名称
- Connection：指定与连接相关的属性，例如（Keep_Alive，长连接）
- Accept-Charset：通知服务器端可以发送的编码格式
- Accept-Encoding：通知服务器端可以发送的数据压缩格式
- Accept-Language：通知服务器端可以发送的语言

响应报文：  

- 协议版本，同请求报文
- 状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错
- 200：响应成功
- 302：跳转，重定向
- 400：客户端有语法错误
- 403：服务器拒绝提供服务
- 404：请求资源不存在
- 500：服务器内部错误
响应头部:  

- Server：服务器应用软件的名称和版本
- Content-Type：响应正文的类型
- Content-Length：响应正文的长度
- Content-Charset：响应正文所使用的编码
- Content-Encoding：响应正文使用的数据压缩格式
- Content-Language：响应正文使用的语言

## 什么是分块传送。
分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。
通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。

如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。
最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。
消息最后以CRLF结尾。




