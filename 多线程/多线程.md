# 1.介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？ 
    - Synchronized修饰成员方法的话锁住的是实例。修饰静态方法的话，锁住的是class对象。

# 2.请你介绍一下volatile？

    - 使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效
    - (非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，
    - 线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。
    - volatile会禁止指令重排 volatile具有可见性、有序性，不具备原子性。 注意，volatile不具备原子性。（不能保证并发累加问题）
    
# 3.Synchronized和Lock的区别？

- synchronized ： 
    - 是一个Java的关键字，JVM隐式锁。
    - 会自动释放锁。
    - 会阻塞。
    - 不可获取锁的状态。
    - 可重入，不可中断，非公平锁
    - 性能没有Lock好。（但是随着JDK版本更迭，其实synchronized的性能也不错）
- Lock:
    - 是java的一个类。
    - 需要手动释放锁。一般在finally中释放。（避免异常的时候没有释放锁）
    - 在阻塞的时候可让出锁。
    - 可以获取锁的状态。
    - 可重入，可中断，可公平。
    - 性能良好。

# 4.wait的底层实现？

  - lock.wait()方法最终通过ObjectMonitor的void wait(jlong millis, bool interruptable, TRAPS)方法实现

1. 将当前线程封装成ObjectWaiter对象node

2. 通过ObjectMonitor::AddWaiter方法将node添加到_WaitSet列表中

3. 通过ObjectMonitor::exit方法释放当前的ObjectMonitor对象，这样其它竞争线程就可以获取该ObjectMonitor对象

4. 最终底层的park方法会挂起线程



# 5.多线程中的i++线程安全吗？为什么？
    不安全。就算i变量加上volatile修饰符的话一样是线程不安全的，因为这里的线程不安全并不是内存可见性造成的。
    是因为i++不是一个原子性操作。i++分为两步操作，一步是i+1，一步是把结果再赋值给i。假设两个线程同时并发执行
    i++操作的话，就会导致少加1的情况。
    
    
# 6.如何线程安全的实现一个计数器？ 
    - 使用原子变量
    - 使用锁机制
    - 自己实现CAS操作
    
# 7.多线程同步的方法 ？
    锁：
    使用synchronized修饰符
    使用wait\notify机制
    使用jdk自带的可重入锁
    线程隔离：
    使用线程局部变量ThreadLocal
    CAS：
    使用CAS操作机制
    使用jdk自带的原子变量
    
# 8.介绍一下生产者消费者模式？
    生产者生产商品进入线程安全的并发队列当中，消费者从这个队列中获取商品进行消费。
    实现并发与解耦。本质上和我们的消息中间件MQ是一样的。
    
    
# 9.线程创建有很大开销时，应该怎么优化？ 
    使用线程池进行优化。
    
    
# 10.请简述一下线程池的运行流程，使用参数以及方法策略等
    - 运行流程
    
    如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
    如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。
    如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，
    建新的线程来处理被添加的任务。
    如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，
    那么通过 handler所指定的策略来处理此任务。
    当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，
    线程池可以动态的调整池中的线程数。
    
    
    - 使用参数

    CorePoolSize:核心线程池大小
    MaximumPoolSize：最大线程数
    WorkQueue：任务缓存队列
    ThreadFactory：线程工厂，主要用来创建线程
    Handler：饱和处理策略 
    
    - 饱和处理策略
    
    ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。
    ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
    ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
    ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务


# 11.讲一下AQS吧。
    AQS的英文是抽象队列同步器的意思。
    首先AQS当中主要有三个东西，一个是state变量，一个是当前线程，一个
    是等待队列。
    它的运作机制主要是线程想获取锁的话，先用CAS的机制将state加1，如果成功
    的话，在将当前线程变量赋值为自身。由于AQS是可重入的，所以第二次加锁的时候
    先判断当前线程变量是否是自身，如果是的话。state变量再进行加1。
    在并发的时候，其他线程想加锁的时候，CAS操作state会失败，进入等待队列。
    如果之前的线程执行完毕的话，会唤醒等待队列中的线程
    
# 12.创建线程的方法，哪个更好，为什么？ 
    - 继承Thread类
    - 实现Runnable接口。较灵活。推荐使用。
    - 实现Callable接口。有返回值。
    
    
# 13.Java中有几种线程池？ 
    1.newFixedThreadPool 这个线程池的corePoolSize和maximumPoolSize大小是一样的
    采用的是LinkedBlockingQueue无界阻塞队列。
    2.newCachedThreadPool
    这个线程池的corePoolSize是0，maximumPoolSize是int最大值
    采用的是SynchronousQueue无缓冲等待队列。
    3.newScheduledThreadPool
    这个线程池采用的是DelayedWorkQueue延迟工作队列。
    4.newSingleThreadExecutor
    这个线程池corePoolSize和maximumPoolSize都是1，
    采用的是LinkedBlockingQueue无界阻塞队列
    
    newFixedThreadPool是固定线程数的线程池，适用于执行长任务，固定线程数避免
    线程切换带来的损耗。
    newCachedThreadPool是缓冲线程池，适用于执行小任务，这些小任务都可以在
    一个时间片内执行完
    newScheduledThreadPool适用于周期性执行任务。
    newSingleThreadExecutor适用于串行化执行任务。
    
    
    
    
    
# 14.线程池的好处？
    a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
    b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
    c. 提供定时执行、定期执行、单线程、并发数控制等功能。
    
# 15.cyclicbarrier和countdownlatch的区别
    CountDownLatch: 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。
    类似于赛跑运动中，所有运动员都跑完了才开始颁奖仪式。
    CyclicBrrier: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。
    类似于赛跑运动中，所有运动员互相等待其他所有人都准备好了，才可以起跑。这场跑完，下一场
    也是需要所有运动员都准备好了，才开始下一轮起跑。（可重复）
    
# 16.如何理解Java多线程回调方法？ 
    java当中的多线程回调主要是利用Callable和Future这两个组件。
    在A线程中调用了一个B线程执行一个操作，在这个操作还未执行完成之前，A线程先去做别的事情，
    等到预估B线程快执行好了之后，A线程去调用get()方法阻塞获取B线程的执行结果。
    
    
# 17.概括的解释下线程的声明周期状态。
    1.新建状态(New)：   new Thread(runable); new操作完成后，此时线程刚被创建是新建状态。
    2.就绪状态(Runnable)： 当调用thread.start()方法被调用的时候，线程进入就绪状态，可以开始抢占cpu
    3.运行状态(Running)： 当线程分配到了时间片之后，开始进入运行状态。
    4.阻塞状态(Blocked)： 当线程还未执行结束前，让出cpu时间片（主动或者被动的），线程进入阻塞状态
    5.死亡状态(Dead)：线程正常运行结束或者遇到一个未捕获的异常，线程进入死亡状态。
    
    
    
# 18.同步方法和同步代码块的区别是什么？
    1锁粒度不同
    2代码块里可以指定同步的标识
    
    
# 19.在监视器(Monitor)内部，是如何做线程同步的？

    AQS的实现原理和底层的Monitor是相似的。
    Monitor是虚拟机底层用C++实现的。
    - _owner：指向持有ObjectMonitor对象的线程
    - _WaitSet：存放处于wait状态的线程队列
    - _EntryList：存放处于等待锁block状态的线程队列
    - _recursions：锁的重入次数
    - _count：用来记录该线程获取锁的次数 
    
    当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。
    若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便_EntryList队列中其他线程进入获取monitor(锁)
    
    一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 
    确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码 。
    
 # 20.请说明一下sleep() 和 wait() 有什么区别？
    sleep是让线程休眠。在一定时间后会自动恢复运行。但是这个操作是不会释放锁操作的。
    wait是让线程等待，一定需要唤醒，才会继续后面的操作。wait是释放锁的。
    这两个方法来自不同的类分别是Thread和Object，sleep方法属于Thread类中的静态方法，wait属于Object的成员方法，
    对此对象调用wait方法导致本线程放弃对象锁。
    wait，notify和notifyAll只能在同步控制方法或者同步控制块（对某个对象同步，然后在块中调用wait或者notify）里面使用，
    而sleep可以在任何地方使用（使用范围）。
    
    
 # 21.同步和异步有何异同，在什么情况下分别使用他们？举例说明。 
    同步：在同一个线程中，语句B必须等待语句A执行完之后，才能继续执行。  例如一条转账记录的生成。
    异步：在一个线程中，执行A语句用另外一个线程运行，A语句还未运行完成前，就直接运行语句B。  例如用户支付时，还未支付成功前
    就直接返回客户端正在支付中的页面，而不是等待支付成功才返回支付成功的页面。
    
    
 # 22.启动一个线程是用run()还是start()? 
    start()
    
    
 # 23.请说出你所知道的线程同步的方法 ？
    synchronized隐式锁
    Lock显示锁
    volatile可见性（但不保证原子性）
    ThreadLocal线程局部变量
    

    
    
    
    
    

