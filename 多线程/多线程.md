# 1.介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？ 
    - Synchronized修饰成员方法的话锁住的是实例。修饰静态方法的话，锁住的是class对象。

# 2.请你介绍一下volatile？

    - 使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效
    - (非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，
    - 线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。
    - volatile会禁止指令重排 volatile具有可见性、有序性，不具备原子性。 注意，volatile不具备原子性。（不能保证并发累加问题）
    
# 3.Synchronized和Lock的区别？

- synchronized ： 
    - 是一个Java的关键字，JVM隐式锁。
    - 会自动释放锁。
    - 会阻塞。
    - 不可获取锁的状态。
    - 可重入，不可中断，非公平锁
    - 性能没有Lock好。（但是随着JDK版本更迭，其实synchronized的性能也不错）
- Lock:
    - 是java的一个类。
    - 需要手动释放锁。一般在finally中释放。（避免异常的时候没有释放锁）
    - 在阻塞的时候可让出锁。
    - 可以获取锁的状态。
    - 可重入，可中断，可公平。
    - 性能良好。

# 4.wait的底层实现？

  - lock.wait()方法最终通过ObjectMonitor的void wait(jlong millis, bool interruptable, TRAPS)方法实现

1. 将当前线程封装成ObjectWaiter对象node

2. 通过ObjectMonitor::AddWaiter方法将node添加到_WaitSet列表中

3. 通过ObjectMonitor::exit方法释放当前的ObjectMonitor对象，这样其它竞争线程就可以获取该ObjectMonitor对象

4. 最终底层的park方法会挂起线程



# 5.多线程中的i++线程安全吗？为什么？
    不安全。就算i变量加上volatile修饰符的话一样是线程不安全的，因为这里的线程不安全并不是内存可见性造成的。
    是因为i++不是一个原子性操作。i++分为两步操作，一步是i+1，一步是把结果再赋值给i。假设两个线程同时并发执行
    i++操作的话，就会导致少加1的情况。
    
    
# 6.如何线程安全的实现一个计数器？ 
    - 使用原子变量
    - 使用锁机制
    - 自己实现CAS操作
    
# 7.多线程同步的方法 ？
    锁：
    使用synchronized修饰符
    使用wait\notify机制
    使用jdk自带的可重入锁
    线程隔离：
    使用线程局部变量ThreadLocal
    CAS：
    使用CAS操作机制
    使用jdk自带的原子变量
    
# 8.介绍一下生产者消费者模式？
    生产者生产商品进入线程安全的并发队列当中，消费者从这个队列中获取商品进行消费。
    实现并发与解耦。本质上和我们的消息中间件MQ是一样的。
    
    
# 9.线程创建有很大开销时，应该怎么优化？ 
    使用线程池进行优化。
    
    
# 10.请简述一下线程池的运行流程，使用参数以及方法策略等
    - 运行流程
    
    如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
    如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。
    如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，
    建新的线程来处理被添加的任务。
    如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，
    那么通过 handler所指定的策略来处理此任务。
    当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，
    线程池可以动态的调整池中的线程数。
    
    
    - 使用参数

    CorePoolSize:核心线程池大小
    MaximumPoolSize：最大线程数
    WorkQueue：任务缓存队列
    ThreadFactory：线程工厂，主要用来创建线程
    Handler：饱和处理策略 
    
    - 饱和处理策略
    
    ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。
    ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
    ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
    ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务


 # 11.讲一下AQS吧。 
    


