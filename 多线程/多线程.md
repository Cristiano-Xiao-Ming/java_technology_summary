# 1.介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？ 
    - Synchronized修饰成员方法的话锁住的是实例。修饰静态方法的话，锁住的是class对象。

# 2.请你介绍一下volatile？

    - 使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效
    - (非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，
    - 线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。
    - volatile会禁止指令重排 volatile具有可见性、有序性，不具备原子性。 注意，volatile不具备原子性。（不能保证并发累加问题）
    
# 3.Synchronized和Lock的区别？

- synchronized ： 
    - 是一个Java的关键字，JVM隐式锁。
    - 会自动释放锁。
    - 会阻塞。
    - 不可获取锁的状态。
    - 可重入，不可中断，非公平锁
    - 性能没有Lock好。（但是随着JDK版本更迭，其实synchronized的性能也不错）
- Lock:
    - 是java的一个类。
    - 需要手动释放锁。一般在finally中释放。（避免异常的时候没有释放锁）
    - 在阻塞的时候可让出锁。
    - 可以获取锁的状态。
    - 可重入，可中断，可公平。
    - 性能良好。

