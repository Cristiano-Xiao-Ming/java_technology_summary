# 1.为什么重写equals还要重写hashcode？

在没有重写equals的情况下，Object父类的equals方法默认比较的是对象在堆中的引用值。
如果重写了equals的话，可以根据自己的规则进行判定两个对象是否相等。（比如学号姓名一样的学生实体即为相等）
但是，如果将实体存进与哈希有关的集合当中时，哈希地址是根据hashcode进行计算的。如果没有重写hashcode的时候，默认返回的是引用值。
这将会导致Hash表当中存入两个相同的学生。


# 2.Object默认的hashcode实现？
Object类对于hashcode并没有具体的实现，调用的是jvm底层的c++代码进行计算。该方法返回的是一个int数字，底层的cpp代码中
一共有六种默认的实现方式。



# 3.==比较的是什么？
在java中==符号比较的是两个对象在内存当中的引用值。



# 4.若对一个类不重写，它的equals()方法是如何比较的？
若不重写equals的话，将直接调用基类Object的equals方法，该方法比较的还是内存当中的引用值。


# 5.java8的新特性。
- lambda表达式支持函数式编程，简化代码。
- 接口可有默认方法与静态方法。
- 方法引用的简便写法。
- 可重复注解。
- 扩展注解的使用范围：局部变量、泛型变量、异常。
- 可获取参数的名字。
- Optional对于Null优雅的处理。
- java集合中的Stream的增强处理（类似数据库），以及并行处理。
- Date/Time API更好的支持。（duration特别好用）
- 内置javasrcipt引擎
- Base64包
- JVM中的永久区被移除，换做元数据区

# 6.lambda表达式的优缺点
  - 优点：
       - 简洁，不再需要匿名内部类。
       - 并行计算在大数据量的情况下会比for循环更块
  - 缺点：
       - 普通情况下比for循环慢
       - 调试不方便
       - 类型转换要特殊处理
       
# 7.一个十进制的数在内存中是怎么存的？
以二进制补码形式存储，最高位是符号位，正数的补码是它的原码，负数的补码是它的反码加1，在求反码时符号位不变，符号位为1，其他位取反


# 8.浮点数为什么精度会发生丢失？
2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。
例如0.125 二进制表示为0.001  但0.4转换为二进制的话，计算会出现无限小数。所以会导致精度丢失。

# 9.Java支持的数据类型有哪些？什么是自动拆装箱？ 
   - char
   - byte 
   - short
   - boolean
   - long
   - float
   - double
   - int
自动拆装箱是在代码编译之后，自动进行 int i = Integer.valueOf(i) 的转换操作，最早的1.5JDK之前没有自动拆装箱，所以当时是需要手动写拆箱装箱。


# 10.什么是值传递和引用传递？
值传递代表的是将实参的拷贝传给形参，形参的改变并不会影响到实参。
引用传递指的是将实参的引用值传给行参，方法内基于引用值找到对象并修改对象中的值是会生效的，但地址值依然是拷贝，无法生效。

# 11.int 和 Integer 有什么区别？
   - int是基本类型，Integer是int的包装类型。
   - int的默认值是0,Integer的默认值null。
   - Integer缓存了-128~127之间的数。
  
# 12.String和StringBuffer的区别？
  - String不可变，进行更改字符串的话相当于改了字符串的引用。
  - StringBuffer可变，修改字符串是基于原来的字符串进行修改，不会创建新的字符串。





