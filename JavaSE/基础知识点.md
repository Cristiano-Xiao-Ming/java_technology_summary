# 1.为什么重写equals还要重写hashcode？

在没有重写equals的情况下，Object父类的equals方法默认比较的是对象在堆中的引用值。
如果重写了equals的话，可以根据自己的规则进行判定两个对象是否相等。（比如学号姓名一样的学生实体即为相等）
但是，如果将实体存进与哈希有关的集合当中时，哈希地址是根据hashcode进行计算的。如果没有重写hashcode的时候，默认返回的是引用值。
这将会导致Hash表当中存入两个相同的学生。


# 2.Object默认的hashcode实现？
Object类对于hashcode并没有具体的实现，调用的是jvm底层的c++代码进行计算。该方法返回的是一个int数字，底层的cpp代码中
一共有六种默认的实现方式。



# 3.==比较的是什么？
在java中==符号比较的是两个对象在内存当中的引用值。



# 4.若对一个类不重写，它的equals()方法是如何比较的？
若不重写equals的话，将直接调用基类Object的equals方法，该方法比较的还是内存当中的引用值。


# 5.java8的新特性。
- lambda表达式支持函数式编程，简化代码。
- 接口可有默认方法与静态方法。
- 方法引用的简便写法。
- 可重复注解。
- 扩展注解的使用范围：局部变量、泛型变量、异常。
- 可获取参数的名字。
- Optional对于Null优雅的处理。
- java集合中的Stream的增强处理（类似数据库），以及并行处理。
- Date/Time API更好的支持。（duration特别好用）
- 内置javasrcipt引擎
- Base64包
- JVM中的永久区被移除，换做元数据区

# 6.lambda表达式的优缺点
  - 优点：
       - 简洁，不再需要匿名内部类。
       - 并行计算在大数据量的情况下会比for循环更块
  - 缺点：
       - 普通情况下比for循环慢
       - 调试不方便
       - 类型转换要特殊处理
       
# 7.一个十进制的数在内存中是怎么存的？
以二进制补码形式存储，最高位是符号位，正数的补码是它的原码，负数的补码是它的反码加1，在求反码时符号位不变，符号位为1，其他位取反


# 8.浮点数为什么精度会发生丢失？
2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。
例如0.125 二进制表示为0.001  但0.4转换为二进制的话，计算会出现无限小数。所以会导致精度丢失。

# 9.Java支持的数据类型有哪些？什么是自动拆装箱？ 
   - char
   - byte 
   - short
   - boolean
   - long
   - float
   - double
   - int
自动拆装箱是在代码编译之后，自动进行 int i = Integer.valueOf(i) 的转换操作，最早的1.5JDK之前没有自动拆装箱，所以当时是需要手动写拆箱装箱。


# 10.什么是值传递和引用传递？
值传递代表的是将实参的拷贝传给形参，形参的改变并不会影响到实参。
引用传递指的是将实参的引用值传给行参，方法内基于引用值找到对象并修改对象中的值是会生效的，但地址值依然是拷贝，无法生效。

# 11.int 和 Integer 有什么区别？
   - int是基本类型，Integer是int的包装类型。
   - int的默认值是0,Integer的默认值null。
   - Integer缓存了-128~127之间的数。
  
# 12.String和StringBuffer的区别？
  - String不可变，进行更改字符串的话相当于改了字符串的引用。
  - StringBuffer可变，修改字符串是基于原来的字符串进行修改，不会创建新的字符串。
  
# 13.如何输出一个某种编码的字符串？ 
  - new String(str.getBytes("ISO-8859-1"), "GBK");  通过添加字符编码进行转换。
  
# 14.&和&&的区别？
  - 一个是按位与，一个是逻辑与。逻辑与会短路。按位与不会短路。
  
# 15.在Java中，如何跳出当前的多重嵌套循环？ 
  - 定义一个标号。然后在内层循环当中break 标号；
  
  ```
        ok:

        for (int j = 0; j < 1000; j++) {
            for (int k = 0; k < 1000; k++) {
                System.out.println(k);
                break ok;
            }
        }
  
  ```
  
# 16.你能比较一下Java和JavaSciprt吗？
   - java是编译型语言，强类型，面向对象。由JVM执行。
   - javascript是解释性语言，弱类型，一般面向过程。由浏览器引擎执行。
   
   
# 17.简述正则表达式及其用途。 
   - 主要用来匹配出特定规则的字符串。（如电话号码）
   
# 18.Java中是如何支持正则表达式操作的？ 
   - String类中的split\match\replace 等方法都支持正则。
   - Pattern类支持正则。
   
   

# 19.Java有哪些特性，举个多态的例子。 
  - 例如Animal类型都有move方法，Cat和Bird都集成了Animal类。但是Cat的move是用四肢跑。Bird的move使用翅膀飞。
  - 多态是一种动态方法绑定的机制。
  
# 20.类和对象的区别？
  - 好比猫属于生物中的一个物种（类）。而家里养了一只叫kitty的猫，kitty就是猫这个物种中一个具体并真实存在的对象。
  
# 21.Object当中的主要方法？
    - getClass() ： 获取对象所属类型
    - hashCode() ： 获取对象的
    - equals()   ： 判断对象是否相等
    - toString() ： 将对象转换为字符串
    - clone()    ： 克隆一个对象
    - wait()...  ： 暂停线程让出锁，进入锁池
    - notify()   ： 唤醒线程
    - notifyAll()： 唤醒所有线程
    - finalize() ： 在对象回收时会执行的方法


# 22.为什么String不可变？
  - 因为String类中持有的value数组使用final进行修饰的，所以它的数组引用就变成不可变的了。
  - 这么做的原因之一是因为String有常量池这个概念。比如一个String a在常量池中被很多变量
  - 引用了，如果String是可变的，当改变了a当中的字符，会造成所有引用这个字符变量的地方都跟着改变。
  - 但如果String是不可变的话，a原本的字符不变，将一个新的字符串赋予给a，这样就不会影响到其他引用之前a字符串的地方。
  
# 23.重载和重写的区别？相同参数不同返回值能重载吗？ 

  - 重载是在同一个类中，方法名一样，但参数列表不一样的静态多态。虚拟机无法根据返回值的不同来判断使用哪个重载方法。
  - 重写是子类重写了父类的方法，方法签名一样，但实现不一样。


# 24.static关键字是什么意思？
  - static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）
  - static修饰方法， static 方法就是没有 this 的方法。在 static 方法内部不能调用非静态方法，反过来是可以的。<br>
  而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用 static 方法。这实际上正是 static 方法的主要用途。 <br>方便在没有创建对象的情况下来进行调用（方法/变量）。 
  - static修饰变量，就变成了静态变量，随类加载一次，可以被多个对象共享。 
  - static修饰代码块，形成静态代码块，用来优化程序性能，将需要加载一次的代码设置成随类加载，静态代码块可以有多个。
  
# 25.Java中是否可以覆盖(override)一个private或者是static的方法？
  -  Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。
还有私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 

# 26.String能继承吗？
  - 不能，因为String类是经过final修饰的。
  - 这么做的原因可能是因为String是底层的类，用final修饰的话，自然而然的方法也会被final修饰。因此在调用String的任何方法的时候，都采用JVM的内嵌机制，效率会有较大的提升。
  - 还有可能是出于安全的考虑，防止继承的子类改写String的方法，再将子类以String父类的形式进行调用。
  
# 27.StringBuffer和StringBuilder有什么区别，底层实现上呢？ 
  - StringBuffer是线程安全的，性能稍慢。StringBuilder是线程不安全的，性能较快。
  - 底层实现上其实是StringBuffer的方法多了synchronized修饰符。
  
# 28.类加载机制的双亲委派模型，好处是什么？ 
  - 双亲委派模型是每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成加载，那么子类尝试自己加载。
  - 双亲委派机制可以避免加载子类自定义的Object类、String类等一些跟jdk命名相同的类。使得加载的类都是同一个。这样才安全。
  
# 29.静态变量存在哪里？
  - 存在方法区（永久代，在1.8之后是元数据区）当中。
  
# 30.什么是泛型？
  - 泛型是参数化类型。避免为不同类型参数的方法进行多次重载，方便开发。并且编译器会进行泛型的检查，在开发上更安全。
  - 但是泛型信息在运行时其实是擦除的。
  
  




