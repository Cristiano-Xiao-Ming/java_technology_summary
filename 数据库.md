# 1.有一个组合索引（A,B,C），可以有哪几种查询方式？
    有A,AB,ABC三种查询方式。如果是AC的话，数据库会先利用索引查找到A索引的所有节点，接下来查找C节点时，
    则没有使用索引。但并非使用了AC的查询就不走索引。但是如果是BC的话，则不走索引，因为在数据库的B树当中
    是以A节点开始索引的。
    
# 索引失效的原因有哪些？如何优化避免索引失效？
可以从索引的结构进行分析
1.索引树不存null值，不走索引
2.值变化太少的列，可能不走这个值的索引，或者直接走全表
3.索引树按照索引字符串是从首字母开始查找，所以前模糊查找不生效（类似多列索引，查询字段用后面的字段造成不走索引）
4.不确定的符号比较（无法在树中定位元素），比如<>、not in、not exist 之类的无法缩小查找范围的搜索。
5.mysql自己估计全表扫描效率更高就不走索引了。

所以判断为何索引失效主要要从索引的结构去分析。大部分不走索引的情况都是因为条件是发散的，而不是收敛的。
    
# 2.数据库水平切分，垂直切分？
    水平切分指的是拆分一张表中的行。
    垂直切分指的是拆分一张表中的列。
    
# 3.数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。
  - 如果是读多写少的项目,可以考虑使用MyISAM,MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。
  - 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎
  - 如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select 
  count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。

# 4.数据库两种引擎

    1. InnoDB支持事务与外键和行级锁,MyISAM不支持(最主要的差别)
    2. MyISAM读性能要优于InnoDB,除了针对索引的update操作,MyISAM的写性能可能低于InnoDB,其他操作MyISAM的
    写性能也是优于InnoDB的,而且可以通过分库分表来提高MyISAM写操作的速度
    3. MyISAM的索引和数据是分开的,而且索引是压缩的,而InnoDB的索引和数据是紧密捆绑的,没有使用压缩,所以InnoDB
    的体积比MyISAM庞大
    4. MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，
    这样的索引称为“非聚簇索引”。其检索算法：先按照B+Tree的检索算法检索，找到指定关键字，则取出对应数据域的值，作为地
    址取出数据记录。InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。这样的索引被称为“聚簇索引”，一个
    表只能有一个聚簇索引。
    5. InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有
    多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。
    6. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    7. innoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update
    table set num=1 where name like “%aaa%” 在where条件没有主键时,InnoDB照样会锁全表
    
# 什么是行锁、表锁、读锁、写锁，说说它们各自的特性？
行锁和表锁是从锁的粒度上来讲。行锁并发高，表锁并发低。
因为行锁有多个，所以会出现互相等待锁的情况，导致死锁。
读锁是S锁，共享锁。写锁是X锁，排他锁。
悲观锁是认为数据极有可能被修改，所以每次都加锁。
乐观锁原理应该还是CAS,认为修改的操作不多，不加锁。再并发较小的情况下建议乐观锁。

# Mysql怎么分表，以及分表后如果想按条件分页查询怎么办
垂直分表和水平分表。
水平分表：根据一列或多列数据的值把数据行放到两个独立的表中。
垂直分表：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。


水平分表分页：一定要限定分表条件，否则性能很慢
垂直分表分页：尽量反模式将查询参数放入主表，非查询参数放入其他表。

# 分表之后想让一个id多个表是自增的，效率实现
flicker实现：选择ID数据库的ID表的自增Id作为多个真实业务表的自增id，ID数据库可以多台，并设置自增步长。
twitter实现：雪花算法。
缓存实现：redis或者memcached
 
 
# MySQL如何启动慢查询日志？
mysql> set global slow_query_log=ON;
mysql> set global slow_launch_time=5; 

# union和union all的区别？
union 有排重   union all 没有排重


# 什么情况下行锁变表锁？
更新操作要全表扫描的情况下，会锁表。在某些情况下，例如索引失效（没有加引号的情况下），索引失效导致扫全表，进而锁全表。


# 什么情况下会出现间隙锁？
更新操作涉及一个索引范围内的更新，新增的一条数据之前不存在这个索引，但也在这个索引范围内的话，会导致幻读，所以会出现间隙锁。


# 谈谈你对MySQL的in和exists用法的理解？
     exist在筛选出每行数据的时候都去判断是否存在。
     In先计算出子查询中的数据，再根据这些数据去外层查询中筛选条件。



# 什么是B-Tree？
节点含有多元素，叶节点再根据父节点中的元素分叉下去。相当于二叉树的多阶版本。


# 什么是B+Tree？
结构和B-树差不多，最后一层叶节点会存父节点值，并用链接成链表。非叶子节点只存关键字，形成稀疏索引。

# MySQL数据库索引结构？
一般有hash索引和B+树索引

    
# 5.简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效 

    B+树实现的。 没有遵循最左匹配原则。 一些关键字会导致索引失效，例如 or， ！= ， not in，,is not null like查询是以%开头
    隐式转换会导致索引失效。 对索引应用内部函数，索引字段进行了运算。
    简而言之，就是搜索条件如果不是收敛的话，就不会走索引。

# MySQL如何使用show Profile进行SQL分析？
我一般使用explain， show profile的数据会自动出现在navicat的结果栏中

# 一条执行慢的SQL如何进行优化，如何通过Explain+SQL分析性能？
尽量调整SQL让他走索引，尽量减少扫描次数，或者关联表次数，实在不行只能加索引
    
# 6.数据库的隔离级别
- 读未提交（Read Uncommitted）：只处理更新丢失。如果一个事务已经开始写数据，则不允许其他事务同时进行写操作，  
但允许其他事务读此行数据。可通过“排他写锁”实现。
- 读提交（Read Committed）：处理更新丢失、脏读。读取数据的事务允许其他事务继续访问改行数据，但是未提交的写事  
务将会禁止其他事务访问改行。可通过“瞬间共享读锁”和“排他写锁”实现。
- 可重复读取（Repeatable Read）：处理更新丢失、脏读和不可重复读取。读取数据的事务将会禁止写事务，但允许读事务，  
写事务则禁止任何其他事务。可通过“共享读锁”和“排他写锁”实现。
- 序列化（Serializable）：提供严格的事务隔离。要求序列化执行，事务只能一个接一个地执行，不能并发执行。  
仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

DB的特性和隔离级别

4大特性：原子性，一致性，分离性，持久性
隔离级别：
读提交：写事务禁止读
读未提交：写事务允许读
可重复读：写事务禁止读事务，读禁止写
序列化：全部禁止
详细说明：读提交1个事务开始写则全部禁止其他事务访问该行。读未提交1个事务开始写则不允许其他事务同时写，但可以读。可重复读 读事务会禁止写事务，写事物则禁止其他任何事务。序列化性能最低，全部禁止，串行执行。 MYSQL默认的是可重复读。


# 7.数据库的乐观锁和悲观锁？
- 乐观锁适用于写少读多的情景，因为这种乐观锁相当于JAVA的CAS，所以多条数据同时过来的时候，不用等待，可以立即进行返回。
- 悲观锁适用于写多读少的情景，这种情况也相当于JAVA的synchronized，reentrantLock等，大量数据过来的时候，只有一条数
据可以被写入，其他的数据需要等待。执行完成后下一条数据可以继续。

- 乐观锁采用版本号的方式，即当前版本号如果对应上了就可以写入数据，如果判断当前版本号不一致，那么就不会更新成功，
- 悲观锁实现的机制一般是在执行更新语句的时候采用for update方式。


# 8.数据库的三范式？
  - 第一范式：每一列不能再拆分原子数据项（不能表嵌套表，但我们开发中的,1,2,3,格式字段就属于反范式）
  - 第二范式：在第一范式的基础上属性完全依赖于主键，不能部分依赖。（比如学生课程分数表{学号，课程号，分数，学生姓名}，这里  
  分数是完全依赖于学号和课程号的，但是学生姓名仅依赖于学号，所以学生姓名必须移出去。但是开发中有时候也会反范式）
  - 第三范式：在第二范式的基础之上，非主键列必须直接依赖于主键不能存在传递依赖。（比如学生信息表{学号，学生姓名，学院号，  
  学院名称}，学院号依赖学号，学院名称又依赖学院号，存在传递依赖。这里和第二范式不一样，第二范式要求完全依赖，而第三范式要  
  求不能传递依赖。
  
  
# 9.数据库的ACID?

- 原子性(atomicity): 一个事物必须被视为一个不可分割的最小工作单元，整个事物中的操作要么全部提交成功，  
要么全部失败回滚，对于一个事物来说，不可能只执行其中的一部分操作，这就是的原子性。  
- 一致性(consistency): 数据库总是从一个一致性的状态转到另一个事务的一致性状态。 (假设用户A和用户B两者的钱  
加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000)
- 隔离性(isolation):一个事物所做的修改在最终提交前，对其他事物是不可见的。在前面的例子中，如果执行到第A账  
户扣100，此时有另一个账户汇款，则其看见的A账户得余额并没有被减去100。 
- 持久性(durability): 一旦事物提交，则其所做的修改就会永远保存在数据库中。 


# 10.mysql的主从复制原理？
1. Slave上面的IO线程连接上Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容;
2. Master接收到来自Slave的IO线程的请求后，通过负责复制的IO线程根据请求信息读取指定日志指定位置之后的日志信息，  
返回给Slave端的 IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在Master端的Binary Log文件的  
名称以及在Binary Log中的位置;
3. Slave的IO线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的RelayLog文件(mysql-relay-bin.xxxxxx)  
的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚  
的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”。
4. Slave的SQL线程检测到Relay Log中新增加了内容后，会马上解析该Log文件中的内容成为在Master 端真实执行时候的  
那些可执行的Query语句，并在自身执行这些Query。这样，实际上就是在Master端和Slave端执行了同样的Query，所以两  
端的数据是完全一样的。


# 11.leftjoin和rightjoin的区别？
    left join 按左表为基础表与右表连接，找不到对应连接的右表，设置为null
    right join 按右表为基础表与左表连接，找不到对应连接的左表，设置为null
    inner join 输出两表都存在对应连接的行数。
    
# 12.数据库的优化。
- 软优化
    - 查询语句优化
    - 优化子查询
    - 使用索引
    - 分解表
    - 增加中间表
    - 增加冗余字段
    - 分析表、检查表、优化表
- 硬优化
    - cpu、内存、硬盘
    - 参数设置
    - 分库分表、读写分离
    
# 什么是索引？什么条件适合建立索引？什么条件不适合建立索引？
索引就是构建出能快速定位出元素的数据结构，例如哈希或者树。
适合做索引：主键、查询条件、关联字段、排序、分组
不适合做索引：频繁更新、不会出现在where中，不进行关联，字段变化太少的字段
    
# 13.数据库连接池的工作原理？
    由于程序每次创建和关闭数据库连接都比较耗费资源，所以引入数据库连接池。在程序启动时初始化多个数据库连接，
    需要访问数据库时就在连接池中获取连接对象，使用完毕后释放连接对象。如果访问超过连接池数量则会等待。
    
# 14.jdbc如何控制事务的？
自动提交事务：默认setAutocommit(true)
手动提交事务：setAutocommit(false)  commit提交 rollback回滚


# 15.JDBC的反射，反射都是什么？
    通过反射加载类驱动。

# 16.Statement和PreparedStatement有什么区别？哪个性能更好？

与Statement相比:  

- PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性  
（减少SQL注射攻击的可能性）；
- PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；
- 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译  
优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）

    
# count(*)、count(列名)和count(1)的区别？
  COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。
在官方文档中：
InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.
表明count(*)和count(1)无区别



## mysql数据库锁表怎么解决？

答：查询锁表信息
当前运行的所有事务
select * from information_schema.innodb_trx
当前出现的锁
select * from information_schema.innodb_locks
锁等待的对应关系
select * from information_schema.innodb_lock_waits  
通过 select * from information_schema.innodb_trx 查询 trx_mysql_thread_id
然后执行 kill 线程ID
KILL   8807;//后面的数字即时进程的ID


## 聚集索引和非聚集索引的区别？


聚集索引：
索引中键值的逻辑顺序决定了表中相应行的物理顺序（索引中的数据物理存放地址和索引的顺序是一致的），可以这么理解：只要是索引是连续的，那么数据在存储介质上的存储位置也是连续的。
比方说：想要到字典上查找一个字，我们可以根据字典前面的拼音找到该字，注意拼音的排列时有顺序的。
聚集索引就像我们根据拼音的顺序查字典一样，可以大大的提高效率。在经常搜索一定范围的值时，通过索引找到第一条数据，根据物理地址连续存储的特点，然后检索相邻的数据，直到到达条件截至项。
非聚集索引
索引的逻辑顺序与磁盘上的物理存储顺序不同。非聚集索引的键值在逻辑上也是连续的，但是表中的数据在存储介质上的物理顺序是不一致的，即记录的逻辑顺序和实际存储的物理顺序没有任何联系。索引的记录节点有一个数据指针指向真正的数据存储位置。
总结如下：
如果一个主键被定义了，那么这个主键就是作为聚集索引
如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引
如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。
InnoDB引擎会为每张表都加一个聚集索引，而聚集索引指向的的数据又是以物理磁盘顺序来存储的，自增的主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。如果对聚集索引进行排序，这会带来磁盘IO性能损耗是非常大的。


## 数据库的锁？

行锁（共享锁和排他锁），表锁，页级锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等

## MyIsam和InnoDB锁的不同
MyISM采用表级锁，对Myism表读不会阻塞读，会阻塞同表写，对Myism写则会阻塞读和写，即一个线程获得1个表的写锁后，只有持有锁的线程可以对表更新操作，其他线程的读和写都会等待。

InnoDB，采用行级锁，支持事务，例如只对a列加索引，如果update ...where a=1 and b=2其实也会锁整个表， select 使用共享锁，update insert delete采用排它锁，commit会把锁取消，当然select by id for update也可以制定排它锁。
