# 1.有一个组合索引（A,B,C），可以有哪几种查询方式？
    有A,AB,ABC三种查询方式。如果是AC的话，数据库会先利用索引查找到A索引的所有节点，接下来查找C节点时，
    则没有使用索引。但并非使用了AC的查询就不走索引。但是如果是BC的话，则不走索引，因为在数据库的B树当中
    是以A节点开始索引的。
    
# 索引失效的原因有哪些？如何优化避免索引失效？
可以从索引的结构进行分析
1.索引树不存null值，不走索引
2.值变化太少的列，可能不走这个值的索引，或者直接走全表
3.索引树按照索引字符串是从首字母开始查找，所以前模糊查找不生效（类似多列索引，查询字段用后面的字段造成不走索引）
4.不确定的符号比较（无法在树中定位元素），比如<>、not in、not exist 之类的无法缩小查找范围的搜索。
5.mysql自己估计全表扫描效率更高就不走索引了。

所以判断为何索引失效主要要从索引的结构去分析。大部分不走索引的情况都是因为条件是发散的，而不是收敛的。
    
# 2.数据库水平切分，垂直切分？
    水平切分指的是拆分一张表中的行。
    垂直切分指的是拆分一张表中的列。
    
# 3.数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。
  - 如果是读多写少的项目,可以考虑使用MyISAM,MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。
  - 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎
  - 如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select 
  count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。

# 4.数据库两种引擎

    1. InnoDB支持事务与外键和行级锁,MyISAM不支持(最主要的差别)
    2. MyISAM读性能要优于InnoDB,除了针对索引的update操作,MyISAM的写性能可能低于InnoDB,其他操作MyISAM的
    写性能也是优于InnoDB的,而且可以通过分库分表来提高MyISAM写操作的速度
    3. MyISAM的索引和数据是分开的,而且索引是压缩的,而InnoDB的索引和数据是紧密捆绑的,没有使用压缩,所以InnoDB
    的体积比MyISAM庞大
    4. MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，
    这样的索引称为“非聚簇索引”。其检索算法：先按照B+Tree的检索算法检索，找到指定关键字，则取出对应数据域的值，作为地
    址取出数据记录。InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。这样的索引被称为“聚簇索引”，一个
    表只能有一个聚簇索引。
    5. InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有
    多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。
    6. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    7. innoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update
    table set num=1 where name like “%aaa%” 在where条件没有主键时,InnoDB照样会锁全表
    
# 什么是行锁、表锁、读锁、写锁，说说它们各自的特性？
行锁和表锁是从锁的粒度上来讲。行锁并发高，表锁并发低。
因为行锁有多个，所以会出现互相等待锁的情况，导致死锁。
读锁是S锁，共享锁。写锁是X锁，排他锁。
悲观锁是认为数据极有可能被修改，所以每次都加锁。
乐观锁原理应该还是CAS,认为修改的操作不多，不加锁。再并发较小的情况下建议乐观锁。
 
 
# MySQL如何启动慢查询日志？
mysql> set global slow_query_log=ON;
mysql> set global slow_launch_time=5; 

# union和union all的区别？
union 有排重   union all 没有排重


# 什么情况下行锁变表锁？
更新操作要全表扫描的情况下，会锁表。在某些情况下，例如索引失效（没有加引号的情况下），索引失效导致扫全表，进而锁全表。


# 什么情况下会出现间隙锁？
更新操作涉及一个索引范围内的更新，新增的一条数据之前不存在这个索引，但也在这个索引范围内的话，会导致幻读，所以会出现间隙锁。


# 谈谈你对MySQL的in和exists用法的理解？
     exist在筛选出每行数据的时候都去判断是否存在。
     In先计算出子查询中的数据，再根据这些数据去外层查询中筛选条件。



# 什么是B-Tree？
节点含有多元素，叶节点再根据父节点中的元素分叉下去。


# 什么是B+Tree？
结构和B-树差不多，最后一层叶节点会存父节点值，并用链接成链表。

# MySQL数据库索引结构？
一般有hash索引和B+树索引

    
# 5.简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效 

    B+树实现的。 没有遵循最左匹配原则。 一些关键字会导致索引失效，例如 or， ！= ， not in，,is not null like查询是以%开头
    隐式转换会导致索引失效。 对索引应用内部函数，索引字段进行了运算。
    简而言之，就是搜索条件如果不是收敛的话，就不会走索引。

# MySQL如何使用show Profile进行SQL分析？
我一般使用explain， show profile的数据会自动出现在navicat的结果栏中

# 一条执行慢的SQL如何进行优化，如何通过Explain+SQL分析性能？
尽量调整SQL让他走索引，尽量减少扫描次数，或者关联表次数，实在不行只能加索引
    
# 6.数据库的隔离级别
- 读未提交（Read Uncommitted）：只处理更新丢失。如果一个事务已经开始写数据，则不允许其他事务同时进行写操作，  
但允许其他事务读此行数据。可通过“排他写锁”实现。
- 读提交（Read Committed）：处理更新丢失、脏读。读取数据的事务允许其他事务继续访问改行数据，但是未提交的写事  
务将会禁止其他事务访问改行。可通过“瞬间共享读锁”和“排他写锁”实现。
- 可重复读取（Repeatable Read）：处理更新丢失、脏读和不可重复读取。读取数据的事务将会禁止写事务，但允许读事务，  
写事务则禁止任何其他事务。可通过“共享读锁”和“排他写锁”实现。
- 序列化（Serializable）：提供严格的事务隔离。要求序列化执行，事务只能一个接一个地执行，不能并发执行。  
仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。


# 7.数据库的乐观锁和悲观锁？
- 乐观锁适用于写少读多的情景，因为这种乐观锁相当于JAVA的CAS，所以多条数据同时过来的时候，不用等待，可以立即进行返回。
- 悲观锁适用于写多读少的情景，这种情况也相当于JAVA的synchronized，reentrantLock等，大量数据过来的时候，只有一条数
据可以被写入，其他的数据需要等待。执行完成后下一条数据可以继续。

- 乐观锁采用版本号的方式，即当前版本号如果对应上了就可以写入数据，如果判断当前版本号不一致，那么就不会更新成功，
- 悲观锁实现的机制一般是在执行更新语句的时候采用for update方式。


# 8.数据库的三范式？
  - 第一范式：每一列不能再拆分原子数据项（不能表嵌套表，但我们开发中的,1,2,3,格式字段就属于反范式）
  - 第二范式：在第一范式的基础上属性完全依赖于主键，不能部分依赖。（比如学生课程分数表{学号，课程号，分数，学生姓名}，这里  
  分数是完全依赖于学号和课程号的，但是学生姓名仅依赖于学号，所以学生姓名必须移出去。但是开发中有时候也会反范式）
  - 第三范式：在第二范式的基础之上，非主键列必须直接依赖于主键不能存在传递依赖。（比如学生信息表{学号，学生姓名，学院号，  
  学院名称}，学院号依赖学号，学院名称又依赖学院号，存在传递依赖。这里和第二范式不一样，第二范式要求完全依赖，而第三范式要  
  求不能传递依赖。
  
  
# 9.数据库的ACID?

- 原子性(atomicity): 一个事物必须被视为一个不可分割的最小工作单元，整个事物中的操作要么全部提交成功，  
要么全部失败回滚，对于一个事物来说，不可能只执行其中的一部分操作，这就是的原子性。  
- 一致性(consistency): 数据库总是从一个一致性的状态转到另一个事务的一致性状态。 (假设用户A和用户B两者的钱  
加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000)
- 隔离性(isolation):一个事物所做的修改在最终提交前，对其他事物是不可见的。在前面的例子中，如果执行到第A账  
户扣100，此时有另一个账户汇款，则其看见的A账户得余额并没有被减去100。 
- 持久性(durability): 一旦事物提交，则其所做的修改就会永远保存在数据库中。 


# 10.mysql的主从复制原理？
1. Slave上面的IO线程连接上Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容;
2. Master接收到来自Slave的IO线程的请求后，通过负责复制的IO线程根据请求信息读取指定日志指定位置之后的日志信息，  
返回给Slave端的 IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在Master端的Binary Log文件的  
名称以及在Binary Log中的位置;
3. Slave的IO线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的RelayLog文件(mysql-relay-bin.xxxxxx)  
的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚  
的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”。
4. Slave的SQL线程检测到Relay Log中新增加了内容后，会马上解析该Log文件中的内容成为在Master 端真实执行时候的  
那些可执行的Query语句，并在自身执行这些Query。这样，实际上就是在Master端和Slave端执行了同样的Query，所以两  
端的数据是完全一样的。


# 11.leftjoin和rightjoin的区别？
    left join 按左表为基础表与右表连接，找不到对应连接的右表，设置为null
    right join 按右表为基础表与左表连接，找不到对应连接的左表，设置为null
    inner join 输出两表都存在对应连接的行数。
    
# 12.数据库的优化。
- 软优化
    - 查询语句优化
    - 优化子查询
    - 使用索引
    - 分解表
    - 增加中间表
    - 增加冗余字段
    - 分析表、检查表、优化表
- 硬优化
    - cpu、内存、硬盘
    - 参数设置
    - 分库分表、读写分离
    
# 什么是索引？什么条件适合建立索引？什么条件不适合建立索引？
索引就是构建出能快速定位出元素的数据结构，例如哈希或者树。
适合做索引：主键、查询条件、关联字段、排序、分组
不适合做索引：频繁更新、不会出现在where中，不进行关联，字段变化太少的字段
    
# 13.数据库连接池的工作原理？
    由于程序每次创建和关闭数据库连接都比较耗费资源，所以引入数据库连接池。在程序启动时初始化多个数据库连接，
    需要访问数据库时就在连接池中获取连接对象，使用完毕后释放连接对象。如果访问超过连接池数量则会等待。
    
# 14.jdbc如何控制事务的？
自动提交事务：默认setAutocommit(true)
手动提交事务：setAutocommit(false)  commit提交 rollback回滚


# 15.JDBC的反射，反射都是什么？
    通过反射加载类驱动。

# 16.Statement和PreparedStatement有什么区别？哪个性能更好？

与Statement相比:  

- PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性  
（减少SQL注射攻击的可能性）；
- PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；
- 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译  
优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）

    

