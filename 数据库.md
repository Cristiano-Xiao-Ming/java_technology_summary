# 1.有一个组合索引（A,B,C），可以有哪几种查询方式？
    有A,AB,ABC三种查询方式。如果是AC的话，数据库会先利用索引查找到A索引的所有节点，接下来查找C节点时，
    则没有使用索引。但并非使用了AC的查询就不走索引。但是如果是BC的话，则不走索引，因为在数据库的B树当中
    是以A节点开始索引的。
    
# 2.数据库水平切分，垂直切分？
    水平切分指的是拆分一张表中的行。
    垂直切分指的是拆分一张表中的列。
    
# 3.数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。
  - 如果是读多写少的项目,可以考虑使用MyISAM,MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。
  - 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎
  - 如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select 
  count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。

# 4.数据库两种引擎

    1. InnoDB支持事务与外键和行级锁,MyISAM不支持(最主要的差别)
    2. MyISAM读性能要优于InnoDB,除了针对索引的update操作,MyISAM的写性能可能低于InnoDB,其他操作MyISAM的
    写性能也是优于InnoDB的,而且可以通过分库分表来提高MyISAM写操作的速度
    3. MyISAM的索引和数据是分开的,而且索引是压缩的,而InnoDB的索引和数据是紧密捆绑的,没有使用压缩,所以InnoDB
    的体积比MyISAM庞大
    4. MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，
    这样的索引称为“非聚簇索引”。其检索算法：先按照B+Tree的检索算法检索，找到指定关键字，则取出对应数据域的值，作为地
    址取出数据记录。InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。这样的索引被称为“聚簇索引”，一个
    表只能有一个聚簇索引。
    5. InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有
    多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。
    6. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
    7. innoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update
    table set num=1 where name like “%aaa%” 在where条件没有主键时,InnoDB照样会锁全表
    
    
    
# 5.简单说明一下，数据库索引底层是怎样实现的，哪些情况下索引会失效 

    B+树实现的。 没有遵循最左匹配原则。 一些关键字会导致索引失效，例如 or， ！= ， not in，,is not null like查询是以%开头
    隐式转换会导致索引失效。 对索引应用内部函数，索引字段进行了运算。
    简而言之，就是搜索条件如果不是收敛的话，就不会走索引。
    
    
# 6.数据库的隔离级别
- 读未提交（Read Uncommitted）：只处理更新丢失。如果一个事务已经开始写数据，则不允许其他事务同时进行写操作，  
但允许其他事务读此行数据。可通过“排他写锁”实现。
- 读提交（Read Committed）：处理更新丢失、脏读。读取数据的事务允许其他事务继续访问改行数据，但是未提交的写事  
务将会禁止其他事务访问改行。可通过“瞬间共享读锁”和“排他写锁”实现。
- 可重复读取（Repeatable Read）：处理更新丢失、脏读和不可重复读取。读取数据的事务将会禁止写事务，但允许读事务，  
写事务则禁止任何其他事务。可通过“共享读锁”和“排他写锁”实现。
- 序列化（Serializable）：提供严格的事务隔离。要求序列化执行，事务只能一个接一个地执行，不能并发执行。  
仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。


# 7.数据库的乐观锁和悲观锁？
- 乐观锁适用于写少读多的情景，因为这种乐观锁相当于JAVA的CAS，所以多条数据同时过来的时候，不用等待，可以立即进行返回。
- 悲观锁适用于写多读少的情景，这种情况也相当于JAVA的synchronized，reentrantLock等，大量数据过来的时候，只有一条数
据可以被写入，其他的数据需要等待。执行完成后下一条数据可以继续。

- 乐观锁采用版本号的方式，即当前版本号如果对应上了就可以写入数据，如果判断当前版本号不一致，那么就不会更新成功，
- 悲观锁实现的机制一般是在执行更新语句的时候采用for update方式。


# 8.数据库的三范式？
  - 第一范式：每一列不能再拆分原子数据项（不能表嵌套表，但我们开发中的,1,2,3,格式字段就属于反范式）
  - 第二范式：在第一范式的基础上属性完全依赖于主键，不能部分依赖。（比如学生课程分数表{学号，课程号，分数，学生姓名}，这里  
  分数是完全依赖于学号和课程号的，但是学生姓名仅依赖于学号，所以学生姓名必须移出去。但是开发中有时候也会反范式）
  - 第三范式：在第二范式的基础之上，非主键列必须直接依赖于主键不能存在传递依赖。（比如学生信息表{学号，学生姓名，学院号，  
  学院名称}，学院号依赖学号，学院名称又依赖学院号，存在传递依赖。这里和第二范式不一样，第二范式要求完全依赖，而第三范式要  
  求不能传递依赖。
  
  
# 9.数据库的ACID?

- 原子性(atomicity): 一个事物必须被视为一个不可分割的最小工作单元，整个事物中的操作要么全部提交成功，  
要么全部失败回滚，对于一个事物来说，不可能只执行其中的一部分操作，这就是的原子性。  
- 一致性(consistency): 数据库总是从一个一致性的状态转到另一个事务的一致性状态。 (假设用户A和用户B两者的钱  
加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000)
- 隔离性(isolation):一个事物所做的修改在最终提交前，对其他事物是不可见的。在前面的例子中，如果执行到第A账  
户扣100，此时有另一个账户汇款，则其看见的A账户得余额并没有被减去100。 
- 持久性(durability): 一旦事物提交，则其所做的修改就会永远保存在数据库中。 


# 10.mysql的主从复制原理？
1. Slave上面的IO线程连接上Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容;
2. Master接收到来自Slave的IO线程的请求后，通过负责复制的IO线程根据请求信息读取指定日志指定位置之后的日志信息，  
返回给Slave端的 IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在Master端的Binary Log文件的  
名称以及在Binary Log中的位置;
3. Slave的IO线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的RelayLog文件(mysql-relay-bin.xxxxxx)  
的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚  
的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”。
4. Slave的SQL线程检测到Relay Log中新增加了内容后，会马上解析该Log文件中的内容成为在Master 端真实执行时候的  
那些可执行的Query语句，并在自身执行这些Query。这样，实际上就是在Master端和Slave端执行了同样的Query，所以两  
端的数据是完全一样的。


# 11.leftjoin和rightjoin的区别？
    left join 按左表为基础表与右表连接，找不到对应连接的右表，设置为null
    right join 按右表为基础表与左表连接，找不到对应连接的左表，设置为null
    inner join 输出两表都存在对应连接的行数。
    
# 12.数据库的优化。

