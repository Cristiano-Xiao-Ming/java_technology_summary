
# id全局唯一且自增，如何实现？
Redis的 incr 和 increby 自增原子命令
统一数据库的id发放
美团Leaf
Leaf——美团点评分布式ID生成系统
Twitter的snowflake算法



# 如何设计算法压缩一段URL？
通过发号策略，给每一个过来的长地址，发一个号即可，小型系统直接用mysql的自增索引就搞定了。  
如果是大型应用，可以考虑各种分布式key-value系统做发号器。不停的自增就行了。第一个使用这个  
服务的人得到的短地址是http://xx.xx/0 第二个是 http://xx.xx/1 第11个是 http://xx.xx/a   
第依次往后，相当于实现了一个62进制的自增字段即可。

常用的url压缩算法是短地址映射法。具体步骤是：  

1. 将长网址用md5算法生成32位签名串，分为4段,，每段8个字符；
2. 对这4段循环处理，取每段的8个字符, 将他看成16进制字符串与0x3fffffff(30位1)的位与操作，超过30位的忽略处理；
3. 将每段得到的这30位又分成6段，每5位的数字作为字母表的索引取得特定字符，依次进行获得6位字符串；
4. 这样一个md5字符串可以获得4个6位串，取里面的任意一个就可作为这个长url的短url地址。

# Dubbo负载均衡策略？
随机、轮询、最少使用、一致性哈希（除了一致性哈希外，都有加权）

# Dubbo中Zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
可以，因为dubbo在注册中心挂掉之后，会从原先的缓存中读取连接地址。


# Dubbo完整的一次调用链路介绍？

    调用方：
    1. 将方法名方法参数传入InvokerInvocationHandler的invoke方法中，对于Object中的方法toString, hashCode, equals直接调用invoker的对应方法。
    2. 然后进入（故障转移集群）MockClusterInvoker.invoke()方法中。三种调用策略：①不需要mock， 直接调用FailoverClusterInvoker。②强制mock，调用mock。③先调FailoverClusterInvoker，调用失败在mock.
    3. FailoverClusterInvoker默认调用策略。①通过目录服务查找到所有订阅的服务提供者的Invoker对象。②路由服务根据策略（比如：容错策略）来过滤选择调用的Invokers。③通过负载均衡策略LoadBalance来选择一个Invoker
    4. 执行选择的Invoker.invoker(invocation),经过监听器链，经过过滤器链,执行到远程调用的DubboInvoker。
    5. DubboInvoker根据url 也就是根据服务提供者的长连接，这里封装成交互层对象ExchangeClient供这里调用，判断远程调用类型同步，异步还是oneway模式。ExchangeClient发起远程调用。
    6.获取调用结果：①Oneway返回空RpcResult②异步，直接返回空RpcResult, ResponseFuture回调③同步， ResponseFuture模式同步转异步，等待响应返回

    消费方：
    1.通过Invocation获取服务名和端口组成serviceKey=com.alibaba.dubbo.demo.DemoService:20880, 从DubboProtocol的exproterMap中获取暴露服务的DubboExporter, 在从dubboExporter 获取invoker返回
    2.经过过滤器链。
    3.经过监听器链。
    4.到达执行真正调用的invoker， 这个invoker由代理工厂ProxyFactory.getInvoker(demoService, DemoService.class, registryUrl)创建，具体请看代理那部分介绍。
    5.调用demoService实例方法，将结果封装成RpcResult返回。
    
    
# SpringCloud和Dubbo有什么不一样？
1.dubbo采用RPC的方式交互，SpringCloud采用Http,restful协议进行交互。
2.dubbo依赖zookeeper进行服务注册，Springloud自己拥有自己的服务注册中心。
3.dubbo需要强依赖，需要持有相同的类或者jar包，springcloud弱依赖，但需要通过接口文档进行约束。
4.C数据一致性，A服务可用性，P服务对网络分区故障的容错性，Zookeeper 保证的是CP，
euraka保证的是AP。


# 使用Redis如何实现分布式锁？

redis创建一个订单id，和客户端id，和生存时间。默认一个线程会一直延长这个生存时间。如果其他线程查询到这个值，
并且客户端的id不是自己的话，判断这个锁被别人用了。


# Tomcat如何优化？
虚拟机参数：1.server模式。2.最大堆最小堆大小。3.年轻代和老年代的比例。
4.开启优化。5.使用偏向锁。6.gc年龄。7.合适的gc
tomcat参数：1.maxThread。2.minThread。3.acceptCoun。4.connectionTimeout。6.maxProcessors与minProcessors。


# 后台系统怎么防止请求重复提交？
1.通过数据库订单的状态。（事务的情况）
2.缓存锁定订单号。
3.会话记录请求url
4.申请凭证。


# 后台系统怎么防止请求频繁？
根据用户id，存入一个用户id，和调用次数的值，值的过期时间为2秒。
当超过10的话，提示请求频繁

# 请谈谈单点登录原理？

同域下的单点登录，只需共享session即可。
登录业务系统，跳转至SSO服务器，判断用户名密码正确，在sso域下种下cookie，在session中标记为登录，返回一个ticket，跳转到业务系统，业务系统再拿这个ticket跑去SSO服务器验证ticket是否有效，有效的话，在业务系统session中设置为已登录即可。



# Linux常见命令有哪些？
cd、ls、grep、find、cp、mv、rm、ps、kill、killall、file、tar
cat、chgrp、chown、chmod、vim、gcc、time

# 请说说什么是Maven的依赖、继承以及聚合？
依赖是jar之间的依赖。
聚合是项目中多模块构建。
继承是子模块复用父模块的公共依赖。

# Git暂存区和工作区的区别？

git add命令实际上就是把要提交的所有修改放到暂存区（Stage）
git commit就可以一次性把暂存区的所有修改提交到分支


# Git如何创建、回退以及撤销版本？

git checkout -- filename
git reset --hard HEAD^

# 谈谈项目中分布式事务应用场景？
先理解CAP原理。
①分库分表的情况下
②一个事务涉及到订单的数据库和账户的数据库


## MQ和数据库的一致性问题。
MQ做数据同步也会造成不一致，又需要引入监控，实时计算2个集群的数据同步，做一致性同步。大部分来说，同步es和solr不要在代码中去同步，同步失败无法保证事务，而且业务耦合。可以使用Databug和cancel等工具去做代码解耦，MQ支持重试，存储失败后抛出异常下次再处理。数据做异构，对外服务时任意拼装，MYSQL在半同步复制上做了一些优化，保证了一致性，引入了诸如paxos等主流算法保证强一致性问题。
当DB（监听从库），binlog有变化，cancel监听到时候解析过滤发送MQ（表名字，主键等）到变化的实时从库中查询数据同步到ES聚合表，MQ可以重试，系统解耦。事务log挖掘县城会对DB的事务log监听，并把这些事件发布到消息代理。

