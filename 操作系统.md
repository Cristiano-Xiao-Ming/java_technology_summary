# CentOS 和 Linux的关系？
CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，  
RedHat收费，CentOS免费

# 怎么杀死进程？
一般情况下，终止一个前台进程使用 Ctrl + C 就可以了。对于一个后台进程就须用 kill 命令来终止。  
我们会先使用 ps、top 等命令获得进程的 PID，然后使用 kill 命令来杀掉该进程。


# 线程，进程区别？
进程是资源分配的最小单位，线程是CPU调度的最小单位。


# 系统线程数量上限是多少？
具体看内存，还有系统定义的线程数 /proc/sys/kernel/pid_max 32768



# 什么是页式存储？
连续存储管理不足：
- 对空间要求高
- 会形成很多碎片
- 通过移动技术减少碎片会增加系统的开销  

分页式存储管理的基本原理如下：
- 页框：物理地址分成大小相等的许多区,每个区称为一块(又称页框 page frame);
- 页面：逻辑地址分成大小相等的区, 区的大小与块的大小相等,每个区称一个页面(page)。
- 逻辑地址形式：与此对应，分页存储器的逻辑地址由两部分组成：页号和单元号。
- 用户进程在内存空间中的每个页框内的地址是连续的,但页框和页框之间的地址可以不连续
- 页表和地址转换：在进行存储分配时，总是以块(页框)为单位进行分配，一个作业的信息有多少页，那么在把它  
装入主存时就给它分配多少块。但是，分配给作业的主存块是可以不连续的，即作业的信息可按页分散存放在主存  
的空闲块中，这就避免了为得到连续存储空间而进行的移动。


# 操作系统里的内存碎片你怎么理解，有什么解决办法？

内存碎片通常分为内部碎片和外部碎片：
    1. 内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片，  
    通常内部碎片难以完全避免；
    2.外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用  
    的内存区域。
    现在普遍采取的内存分配方式是段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，  
    使段内的页可以不必连续处于同一内存区域。


# 什么情况下会发生死锁，解决策略有哪些？
产生死锁的四个必要条件：
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
所以要根据产生死锁的条件进行预防，并且要尽量避免死锁。所以解决策略有：
（1）破坏互斥条件：
就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。
但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，  
而不去涉及破坏“互斥”条件
（2）破坏“占有并等待”条件：
破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，  
阻止进程在持有资源的同时申请其他资源。
方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或么什么也不给它。这是所谓的“一次性分配”方案。
方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R  
释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。
（3）破坏“不可抢占”条件
破坏“不可抢占”条件就是允许对资源实行抢夺。
方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次  
请求这些资源和另外的资源。
方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两  
个进程的优先级都不相同的条件下，方法二才能预防死锁。
（4）破坏“循环等待”条件
破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号  
顺序（升序）提出。这样做就能保证系统不出现死锁。
避免死锁： 死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法破坏了系统的并行性和并发性。 死锁产生的前三个条件是  
死锁产生的必要条件，也就是说要产生死锁必须具备的条件，而不是存在这3个条件就一定产生死锁，那么只要在逻辑上回避了第四个  
条件就可以避免死锁。 避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程  
链，从而避免死锁。该方法支持多个进程的并行执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程。
总的思路来说，预防死锁就是避免死锁的最好方法！不过一旦预防不了而产生死锁就应该及时中断进程和破坏中断。最有效的两个做法  
就是一，只运行需要的进程程序而禁用其他进程程序，二，重启机器来破坏中断是最直接有效的。 



