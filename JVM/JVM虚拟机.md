
  # 1.JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？
      CMD采用的是标记-清除算法。会导致内存碎片。
      可打开-XX：+UseCMSCompactAtFullCollection开关参数（默认打开）在进行Full GC之前整理内存碎片（称为“压缩”）；
      使用-XX:CMSFullGCsBeforeCompaction参数（默认0）设置多少次不带压缩的Full CG之后才进行一次带压缩的Full GC。
      内存整理无法并行，还需要STW，需要适当调整内存整理的频率，在GC性能与空间利用率之间平衡。
      
      
  # 2.类加载过程 ？
   #### 1.加载
      通过类的全限定名查找到该类的字节码文件，将该字节码文件装载到jvm中，jvm将文件中静态字节码结构转换成
      运行时动态数据结构，并在方法区生成一个定义该类的Class对象，作为方法区中该类的各种数据访问的入口。
   #### 2.验证
      确保该类的字节码文件中所包含的信息是否符合当前虚拟机的要求，不包含有危害虚拟机的信息（主要有四种验证，
      文件格式验证，元数据验证排（语义）、字节码验证（防止危害虚拟机），符号引用验证）
   #### 3.准备   
      为类变量分配内存，并设置一个初始值。被final修饰的类变量，该类型会在编译期就已经被分配并确定
   #### 4.解析
      将常量池中符号间接引用替换成直接引用
   #### 5.初始化
      为类变量、静态代码块进行真正初始化（赋值操作）（类的初始化顺序，如果有父类先初始化父类中类变量
      和静态代码块，在初始化子类的静态变量、静态代码块’） 
      
      
  # 3.JVM分区？
      堆，方法区，虚拟机栈，本地方法栈，程序计数器
      
  # 4.eden区，Survivor区？
      这两个区都是属于新生代。eden区用于存放那些刚被new出来的对象（因为大部分对象都是朝生夕死的，所以eden区的对象生命周期都比较短暂）。
      survivor区分为两个，一个是s1,一个是s2。存在对象的区标记为from，另外一个空的区标记为to。对象会在这两区中倒腾，所以s1这
      轮是from,下一次就是to。
      当eden区满的时候，开始清理eden区和from区，将剩下存活的对象移入to区当中去。
      
  # 5.java虚拟机的主要作用？
      主要作用就是解释运行java字节码程序消除平台相关性。
      
      
  # 6.GC中如何判断对象需要被回收？ 
      可达性分析：通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，
      搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时
      （即从GC Roots节点到该节点不可达），则证明该对象是不可用的。
      引用计数分析:对象每被引用一次就+1，这个规则比较简单，但是会出现两个对象互相引用。但是不可达的情况，却没有被回收。
