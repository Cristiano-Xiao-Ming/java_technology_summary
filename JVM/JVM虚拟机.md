
  # 1.JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？
      CMD采用的是标记-清除算法。会导致内存碎片。
      可打开-XX：+UseCMSCompactAtFullCollection开关参数（默认打开）在进行Full GC之前整理内存碎片（称为“压缩”）；
      使用-XX:CMSFullGCsBeforeCompaction参数（默认0）设置多少次不带压缩的Full CG之后才进行一次带压缩的Full GC。
      内存整理无法并行，还需要STW，需要适当调整内存整理的频率，在GC性能与空间利用率之间平衡。
      
      
  # 2.类加载过程 ？
   #### 1.加载
      通过类的全限定名查找到该类的字节码文件，将该字节码文件装载到jvm中，jvm将文件中静态字节码结构转换成
      运行时动态数据结构，并在方法区生成一个定义该类的Class对象，作为方法区中该类的各种数据访问的入口。
   #### 2.验证
      确保该类的字节码文件中所包含的信息是否符合当前虚拟机的要求，不包含有危害虚拟机的信息（主要有四种验证，
      文件格式验证，元数据验证排（语义）、字节码验证（防止危害虚拟机），符号引用验证）
   #### 3.准备   
      为类变量分配内存，并设置一个初始值。被final修饰的类变量，该类型会在编译期就已经被分配并确定
   #### 4.解析
      将常量池中符号间接引用替换成直接引用
   #### 5.初始化
      为类变量、静态代码块进行真正初始化（赋值操作）（类的初始化顺序，如果有父类先初始化父类中类变量
      和静态代码块，在初始化子类的静态变量、静态代码块’） 
      
      
  # 3.JVM分区？
      堆，方法区，虚拟机栈，本地方法栈，程序计数器
      
  # 4.eden区，Survivor区？
      这两个区都是属于新生代。eden区用于存放那些刚被new出来的对象（因为大部分对象都是朝生夕死的，所以eden区的对象生命周期都比较短暂）。
      survivor区分为两个，一个是s1,一个是s2。存在对象的区标记为from，另外一个空的区标记为to。对象会在这两区中倒腾，所以s1这
      轮是from,下一次就是to。
      当eden区满的时候，开始清理eden区和from区，将剩下存活的对象移入to区当中去。
      
  # 5.java虚拟机的主要作用？
      主要作用就是解释运行java字节码程序消除平台相关性。
      
      
  # 6.GC中如何判断对象需要被回收？ 
      可达性分析：通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，
      搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时
      （即从GC Roots节点到该节点不可达），则证明该对象是不可用的。
      引用计数分析:对象每被引用一次就+1，这个规则比较简单，但是会出现两个对象互相引用。但是不可达的情况，却没有被回收。
      
  # 7.JAVA虚拟机中，哪些可作为GC ROOT对象？
       1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
       2. 本地方法栈中JNI（即一般说的native方法）引用的对象。
       3. 方法区中的静态变量和常量引用的对象。 

  # 8.JVM内存模型是什么？
      JMM(Java Memory Model) 是线程间通信的机制 。线程间共享变量存储在主内存，每个线程都有自己的本地内存，
      存储的是共享变量在本地的副本。
      对应于cpu中的寄存器（主内存）与高速缓存（本地内存），可以这么理解。
      
  # 9.JVM的线程模型是什么？
  
      内核线程(Kernel-Level Thread, KLT) 就是由操作系统内核支持的线程，内核通过操纵调度器(Scheduler)对线程进行调度。
      程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口-轻量级进程(Light Weight Process, LWP)，
      轻量级进程就是我们通常意义上所讲的线程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型
  
      用户线程(User Thread, UT)指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
      用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。因此操作比内核线程更快速，并可以支持更大的线程数量。
      这种进程(不是轻量级进程)与用户线程之间1：N的关系称为一对多的线程模型。
      
      在早期的JVM实现当中使用的是用户线程1：N的一对多线程模型，在当时cpu的核数普遍较少。
      随着cpu的性能演进，核数越来越多了，如果继续采用用户线程模型的话，就很难利用cpu的多核优势。
      
      如果某几个几个JVM线程被映射到一个内核线程后，（1：N或者M:N内存模型）,如果这里面的一个JVM线程发起系统调用导致内核线程阻塞，
      那么剩下的几个线程依旧会被阻塞。
      
      所以现今的JVM实现采用的是1:1的内核线程模型。
      
      
  # 10.JVM的最大内存限制。
      首先JVM内存限制于实际的最大物理内存了 假设物理内存无限大的话 JVM内存的最大值跟操作系统有很大的关系 
      简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB
      （一般来说Windows系统下为1.5G-2G Linux系统 下为2G-3G） 而64bit以上的处理器就不会有限制了。
       
      但是，这里会有一个问题在默认情况下，堆大小在32G以下的话JVM中的引用会占用4个字节。这是JVM在启动的时候就已经决定了的。
      如果你去掉了-XX:-UseCompressedOops选项的话，当然也可以在较小的堆上使用8字节的引用（但在生产系统中这么做是毫无意义的！）。
      一旦堆超过了32G，你就进入到64位的世界里了，因此对象引用就只能是8字节而非4字节了。此时，Java程序的堆中平均
      会有20%的空间是被对象引用占据了。相当于非常浪费，而且垃圾回收时间也会很长。所以每个JVM实例分配的内存最好控制在32G以内。
      
      
  # 11.为什么Java被称作是“平台无关的编程语言”？
      因为JVM针对不同的操作系统进行了的编译，编译的结果统一了对字节码文件的执行。
      通俗的解释就是：有一个中国人（windows平台），还有一个日本人（linux平台），如果要与他们交流的话，我（开发者）必须
      会说中国话，还得会说日本话。这时候一个英国人（JVM虚拟机）同时会中国话和日本话，而这时我让这个英国人当翻译，
      我只需要会英语就行了，英国人会自动将英文翻译成中文和日文。（JVM虚拟机会自动将字节码翻译成平台能理解的操作指令）。
     
  # 12.JVM加载class文件的原理机制？
      1. BootstrapLoader
      BootstrapLoard是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载%JAVA_HOME%/jre/lib,
      -Xbootclasspath参数指定的路径以及%JAVA_HOME%/jre/classes中的类。rt.jar
      
      2. ExtClassLoader  
      Bootstrploader加载ExtClassLoader,并且将ExtClassLoader的父加载器设置为Bootstrploader，
      ExtClassLoader是用Java写的，具体来说就是 sun.misc.Launcher$ExtClassLoader，ExtClassLoader主要加
      载%JAVA_HOME%/jre/lib/ext，此路径下的所有classes目录以及java.ext.dirs系统变量指定的路径中类库。

      3. AppClassLoader
      Bootstrploader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为ExtClassLoader。 
      AppClassLoader也是用Java写成的，它的实现类是sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个
      getSystemClassLoader方法,此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar
      文档，它也是Java程序默认的类加载器。

      双亲委派机制的工作流程：
      1. 当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。
      每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。

      2. 当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，
      首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp ClassLoader.

      3. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。
      
  # 13.请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？
      内存泄漏定义（memory leak）：一个不再被程序使用的对象或变量还在内存中占有存储空间。一次内存泄漏似乎不会
      有大的影响，但内存泄漏堆积后的后果就是内存溢出。
      内存溢出（out of memory）：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，
      但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。
      
      1. 静态集合类：
      如HashMap、LinkedList等等。如果这些容器为静态变量，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，
      从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象
      持有它的引用而导致不能被回收。
      2. 各种连接：
      如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法
      来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、
      Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
      3. 变量不合理的作用域：
      一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致
      内存泄漏的发生。
      4. 内部类持有外部类：
      如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被
      使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。
      5. 改变哈希值：
      当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初
      存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合
      中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露
      6. 单例模式：
      不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式）
      ，如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。
      
        
  # 14.minor gc如果运行的很频繁，可能是什么原因引起的，minor gc如果运行的很慢，可能是什么原因引起的? 
      频繁的原因：
        新生代的内存空间分配过小。
        程序中new太多声明周期短的对象。
        threshold值太高，新生代中的对象迟迟不进入老年代，使得一直占用新生代空间。
      很慢的原因：
        新生代内存空间太大，扫描时间过长。
        对象引用链较长，进行可达性分析时间较长。
        新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。 
        内存分配担保失败，由minor gc转化为full gc。
        采用的垃圾收集器效率较低，比如新生代使用serial收集器。
        
        
 
        
        
  # 15.简述GC算法

    GC算法分成四种：
    标记清除算法：首先先标记，然后统一把标记的对象依次清除，缺点是CPU消耗大，极易出现内存碎片，所以一般用于老年代。
    复制算法：把内存区域分成俩块，每次只使用其中一块，然后把还存活的对象放在另一块中，清空原先的块，这样的话
    不会出现内存碎片。新生代  常用的。
    复制整理：指针碰撞，将使用过的对象移动到内存的一段，不用的放在另一端。
    分代收集：根据不同代的区别，使用符合不同代的算法。

    简单来说minorGC发生在新生代，频繁而且需要开销小，所以采取复制算法。
    老年代：对象相较于新生代gc不频繁且对象少，采取标记清除或者标记整理算法。 
    
  # 16.GC是什么? 为什么要有GC? 
GC即垃圾回收，回收的是不再使用的对象的内存空间。  
在java语言当中封装了内存分配的操作，程序员不需要关心开辟内存空间和释放内存空间。（C++语言就需要）  
就可以把更多精力放在与内存无关的编码上。  
所以java语言需要设计一套方法用于回收程序中不再使用的对象的内存空间，即GC。  
    
    
  # 17.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
      通过可达性分析，回收确定不可达的对象的内存空间。
      不能，调用System.gc()并不一点执行。
      System.gc()可以通知虚拟机进行垃圾回收，但不保证执行。
  
        

