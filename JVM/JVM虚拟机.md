
  # 1.JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？
      CMD采用的是标记-清除算法。会导致内存碎片。
      可打开-XX：+UseCMSCompactAtFullCollection开关参数（默认打开）在进行Full GC之前整理内存碎片（称为“压缩”）；
      使用-XX:CMSFullGCsBeforeCompaction参数（默认0）设置多少次不带压缩的Full CG之后才进行一次带压缩的Full GC。
      内存整理无法并行，还需要STW，需要适当调整内存整理的频率，在GC性能与空间利用率之间平衡。
      
      
  # 2.类加载过程 ？
   #### 1.加载
      通过类的全限定名查找到该类的字节码文件，将该字节码文件装载到jvm中，jvm将文件中静态字节码结构转换成
      运行时动态数据结构，并在方法区生成一个定义该类的Class对象，作为方法区中该类的各种数据访问的入口。
   #### 2.验证
      确保该类的字节码文件中所包含的信息是否符合当前虚拟机的要求，不包含有危害虚拟机的信息（主要有四种验证，
      文件格式验证，元数据验证排（语义）、字节码验证（防止危害虚拟机），符号引用验证）
   #### 3.准备   
      为类变量分配内存，并设置一个初始值。被final修饰的类变量，该类型会在编译期就已经被分配并确定
   #### 4.解析
      将常量池中符号间接引用替换成直接引用
   #### 5.初始化
      为类变量、静态代码块进行真正初始化（赋值操作）（类的初始化顺序，如果有父类先初始化父类中类变量
      和静态代码块，在初始化子类的静态变量、静态代码块’） 
      
      
  # 3.JVM分区？
      堆，方法区，虚拟机栈，本地方法栈，程序计数器
      
  # 4.eden区，Survivor区？
      这两个区都是属于新生代。eden区用于存放那些刚被new出来的对象（因为大部分对象都是朝生夕死的，所以eden区的对象生命周期都比较短暂）。
      survivor区分为两个，一个是s1,一个是s2。存在对象的区标记为from，另外一个空的区标记为to。对象会在这两区中倒腾，所以s1这
      轮是from,下一次就是to。
      当eden区满的时候，开始清理eden区和from区，将剩下存活的对象移入to区当中去。
      
  # 5.java虚拟机的主要作用？
      主要作用就是解释运行java字节码程序消除平台相关性。
      
      
  # 6.GC中如何判断对象需要被回收？ 
      可达性分析：通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，
      搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时
      （即从GC Roots节点到该节点不可达），则证明该对象是不可用的。
      引用计数分析:对象每被引用一次就+1，这个规则比较简单，但是会出现两个对象互相引用。但是不可达的情况，却没有被回收。
      
  # 7.JAVA虚拟机中，哪些可作为GC ROOT对象？
       1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
       2. 本地方法栈中JNI（即一般说的native方法）引用的对象。
       3. 方法区中的静态变量和常量引用的对象。 

  # 8.JVM内存模型是什么？
      JMM(Java Memory Model) 是线程间通信的机制 。线程间共享变量存储在主内存，每个线程都有自己的本地内存，
      存储的是共享变量在本地的副本。
      对应于cpu中的寄存器（主内存）与高速缓存（本地内存），可以这么理解。
      
  # 9.JVM的线程模型是什么？
  
      内核线程(Kernel-Level Thread, KLT) 就是由操作系统内核支持的线程，内核通过操纵调度器(Scheduler)对线程进行调度。
      程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口-轻量级进程(Light Weight Process, LWP)，
      轻量级进程就是我们通常意义上所讲的线程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型
  
      用户线程(User Thread, UT)指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
      用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。因此操作比内核线程更快速，并可以支持更大的线程数量。
      这种进程(不是轻量级进程)与用户线程之间1：N的关系称为一对多的线程模型。
      
      在早期的JVM实现当中使用的是用户线程1：N的一对多线程模型，在当时cpu的核数普遍较少。
      随着cpu的性能演进，核数越来越多了，如果继续采用用户线程模型的话，就很难利用cpu的多核优势。
      
      如果某几个几个JVM线程被映射到一个内核线程后，（1：N或者M:N内存模型）,如果这里面的一个JVM线程发起系统调用导致内核线程阻塞，
      那么剩下的几个线程依旧会被阻塞。
      
      所以现今的JVM实现采用的是1:1的内核线程模型。
      
      
  # 10.JVM的最大内存限制。
      首先JVM内存限制于实际的最大物理内存了 假设物理内存无限大的话 JVM内存的最大值跟操作系统有很大的关系 
      简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB
      （一般来说Windows系统下为1.5G-2G Linux系统 下为2G-3G） 而64bit以上的处理器就不会有限制了。
       
      但是，这里会有一个问题在默认情况下，堆大小在32G以下的话JVM中的引用会占用4个字节。这是JVM在启动的时候就已经决定了的。
      如果你去掉了-XX:-UseCompressedOops选项的话，当然也可以在较小的堆上使用8字节的引用（但在生产系统中这么做是毫无意义的！）。
      一旦堆超过了32G，你就进入到64位的世界里了，因此对象引用就只能是8字节而非4字节了。此时，Java程序的堆中平均
      会有20%的空间是被对象引用占据了。相当于非常浪费，而且垃圾回收时间也会很长。所以每个JVM实例分配的内存最好控制在32G以内。
      
      
  # 11.为什么Java被称作是“平台无关的编程语言”？
      因为JVM针对不同的操作系统进行了的编译，编译的结果统一了对字节码文件的执行。
      通俗的解释就是：有一个中国人（windows平台），还有一个日本人（linux平台），如果要与他们交流的话，我（开发者）必须
      会说中国话，还得会说日本话。这时候一个英国人（JVM虚拟机）同时会中国话和日本话，而这时我让这个英国人当翻译，
      我只需要会英语就行了，英国人会自动将英文翻译成中文和日文。（JVM虚拟机会自动将字节码翻译成平台能理解的操作指令）。
