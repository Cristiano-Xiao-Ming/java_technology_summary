# B+树和B-树原理。
一个m阶的B树具有如下几个特征：

    1.根结点至少有两个子女。
    2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
    3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
    4.所有的叶子结点都位于同一层。
    5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

    
    
一个m阶的B+树具有如下几个特征：

    1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，
    所有数据都保存在叶子节点。
    2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字 
    的大小自小而大顺序链接。
    3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。


# 二叉树任意两个节点之间路径的最大长度？
情况A: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点。  
方案：计算两个节点到根节点的深度相加。
情况B: 路径不穿过根节点，而是左子树或右子树的最大距离路径，取其大者。 
方案：计算两个节点到子树根节点的深度相加

# 如何计算二叉树的深度
    public static int treeDepth(TreeNode root) {
        if (root == null) {
            return 0;
         }
        // 计算左子树的深度
        int left = treeDepth(root.left);
        // 计算右子树的深度
        int right = treeDepth(root.right);
        // 树root的深度=路径最长的子树深度 + 1
        return left >= right ? (left + 1) : (right + 1);
     }
     
     
# 如何打印二叉树每层的节点？
 借助一个队列，先把根节点入队，每打印一个节点的值时，也就是打印队列头的节点时，都会把它的的左右  
 孩子入队，并且把该节点出队。直到队列为空。

# 二叉树的Z型遍历？
借助一个队列和一个栈，方法和打印层遍历类似，区别在于隔层利用栈来逆序遍历。


# 反转单链表？
1. 可以利用栈逆序拼接。
2. 利用三个指针引用，一次性遍历反转，在每次反转两个节点的时候，都需要保存下一个节点，以免丢失原链表。

# 随机链表的复制？
复制成 1->1'->2->2'->3->3' 的链表，然后再拆分出来   1'->2'->3'


# 链表-奇数位升序偶数位降序-让链表变成升序
第一种做法：先将链表拆分成奇数的链表，和偶数的链表，然后翻转偶数的链表，在合并两个链表。

# bucket如果用链表存储，它的缺点是什么？
不支持随机访问，查找的时间复杂度是O(n)

# 如何判断链表检测环？
准备两个遍历，一个遍历1的步长，一个遍历2的步长

# 寻找一数组中前K个最大的数？
最小堆算法


# 求一个数组中连续子向量的最大和
遍历数组，从第一个大于0的数字开始累加，保存最大值，如果累加后的值小于等于0的话，就抛这一下标，    
从下一个下标开始累积，如果超过之前的最大值的话就进行替换。


# 找出数组中和为S的一对组合。
将所有数字放入数字对应下标的数组，有N个相同的数字，该下标的值就为N。
从i下标开始遍历，S-i下标对应值>0的话，就找到组合。 i=s-i的话，做特殊处理。



# 一个数组，除一个元素外其它都是两两相等，求那个元素?
所有值进行异或运算。  最后的值再和0异或，得到原来的值。



# 将一个二维数组顺时针旋转90度，说一下思路。
先找出旋转90度，下标的变换规律。 然后从外圈向内圈旋转变换。



# 各类排序算法总结？
排序算法 | 时间复杂度
--- | ---
冒泡排序 |	O(n2)
选择排序 |	O(n2)
插入排序 |	O(n2)
希尔排序 |	O(n1.5)
快速排序 |	O(N*logN) 
归并排序 |	O(N*logN)
堆排序	  |  O(N*logN)
基数排序 |	O(d(n+r))


详细的表之后再总结


# 快排的原理是什么？
基本思想：（分治）
- 先从数列中取出一个数作为key值；
- 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
- 对左右两个小数列重复第二步，直至各区间只有1个数。

# 堆排序的原理是什么？
- 利用数组建立一个大根堆（父亲比孩子的值大）；
- 把堆顶元素和堆尾元素互换；
- 把堆（无序区）的尺寸缩小1，并调用siftDown(arr, 0,len-1)从新的堆顶元素开始进行堆调整；
- 重复步骤，直到堆的大小为1；

# 归并排序的原理？
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。
首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁，  
取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。



# 找出数据流的中位数？
- 插入排序，然后找到中间位置。
- 借鉴快排的思想，随机取一个数，大于它的排左边，小于它的排右边。检测所选数字是否位于数组中间。  
是的话就返回，不是的话，小于数组中间位置就对右边递归，大于数组中间位置就对左边递归。


# 堆和栈的区别？
- 堆可以被看成是一棵完全二叉树树，如：堆排序。
- 一种先进后出的数据结构。


# Java优先级队列？
PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。  
在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为  
他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，  
入队和出队的时间复杂度是O(log(n))。



# 为什么要设计后缀表达式，有什么好处？
从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，  
进行运算，运算结果进栈，一直到最终获得结果。
对于表达式计算非常方便


# LRU算法的实现原理？
1.用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组  
中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项  
的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。

2.利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），  
则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。

3.利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则  
把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节  
点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样  
一来在链表尾部的节点就是最近最久未访问的数据项。

重写LinkedHashMap
```
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int MAX_CACHE_SIZE;
 
    public LRUCache2(int cacheSize) {
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
        MAX_CACHE_SIZE = cacheSize;
    }
 
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_CACHE_SIZE;
    }
}
```


# 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）
声明一个大小为10000000的数组，每次随机出来的数i，都去数组下标i-1的位置看是否为0，如果为0的话，写入这个数字，并记录数组的真实大小，等数组的真实大小为10000000的时候，停止随机。

# 两个有序数组的合并排序
同时遍历两个数组，每次对比两个数组当前坐标的值哪个小，小的存入新的数组，数组下表往后移一位，大的那边坐标不变，继续下次大小对比。依次循环。

# 一个数组的倒序
每次交换头尾的值，并坐标向中间靠拢。


# 二叉树的前序，中序，后序遍历算法

前序递归：

     public void preOrderTraverse1(TreeNode root) {
        if (root != null) {
            System.out.print(root.val + "->");
            preOrderTraverse1(root.left);
            preOrderTraverse1(root.right);
        }
     }

前序非递归：

    public void preOrderTraverse2(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (node != null || !stack.empty()) {
            if (node != null) {
                System.out.print(node.val + "->");
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tem = stack.pop();
                node = tem.right;
            }
        }
    }



中序递归：

    public void inOrderTraverse(TreeNode root) {
        if (root != null) {
            inOrderTraverse(root.left);
            System.out.print(root.val + "->");
            inOrderTraverse(root.right);
        }
    }

中序非递归：

    public void inOrderTraverse(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tem = stack.pop();
                System.out.print(tem.val + "->");
                node = tem.right;
            }
        }
    }


后序递归：

       public void postOrderTraverse(TreeNode root) {
            if (root != null) {
                postOrderTraverse(root.left);
                postOrderTraverse(root.right);
                System.out.print(root.val + "->");
            }
        }

后序非递归：
public void postOrderTraverse(TreeNode root) {
        TreeNode cur, pre = null;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.empty()) {
            cur = stack.peek();
            if ((cur.left == null && cur.right == null) || (pre != null && (pre == cur.left || pre == cur.right))) {
                System.out.print(cur.val + "->");
                stack.pop();
                pre = cur;
            } else {
                if (cur.right != null)
                    stack.push(cur.right);
                if (cur.left != null)
                    stack.push(cur.left);
            }
        }
    }

层次遍历：

    public void levelOrderTraverse(TreeNode root) {
            if (root == null) {
                return;
            }
            Queue<TreeNode> queue = new LinkedList<TreeNode>();
            queue.add(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + "->");

            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }



# DFS,BFS算法
深度优先算法:利用栈实现
广度优先算法：利用队列来实现



# 逆波兰计算器
利用栈与后缀表达式利于计算机方便计算


# Hoffman 编码
按权重将节点分布在一条右子树上，使得前缀不重复
