# B+树和B-树原理。
一个m阶的B树具有如下几个特征：

    1.根结点至少有两个子女。
    2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
    3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
    4.所有的叶子结点都位于同一层。
    5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

    
    
一个m阶的B+树具有如下几个特征：

    1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，
    所有数据都保存在叶子节点。
    2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字 
    的大小自小而大顺序链接。
    3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。


# 二叉树任意两个节点之间路径的最大长度？
情况A: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点。  
方案：计算两个节点到根节点的深度相加。
情况B: 路径不穿过根节点，而是左子树或右子树的最大距离路径，取其大者。 
方案：计算两个节点到子树根节点的深度相加

# 如何计算二叉树的深度
    public static int treeDepth(TreeNode root) {
        if (root == null) {
            return 0;
         }
        // 计算左子树的深度
        int left = treeDepth(root.left);
        // 计算右子树的深度
        int right = treeDepth(root.right);
        // 树root的深度=路径最长的子树深度 + 1
        return left >= right ? (left + 1) : (right + 1);
     }
     
     
# 如何打印二叉树每层的节点？
 借助一个队列，先把根节点入队，每打印一个节点的值时，也就是打印队列头的节点时，都会把它的的左右  
 孩子入队，并且把该节点出队。直到队列为空。

# 二叉树的Z型遍历？
借助一个队列和一个栈，方法和打印层遍历类似，区别在于隔层利用栈来逆序遍历。


# 反转单链表？
1. 可以利用栈逆序拼接。
2. 利用三个指针引用，一次性遍历反转，在每次反转两个节点的时候，都需要保存下一个节点，以免丢失原链表。

# 随机链表的复制？
复制成 1->1'->2->2'->3->3' 的链表，然后再拆分出来   1'->2'->3'


# 链表-奇数位升序偶数位降序-让链表变成升序
第一种做法：先将链表拆分成奇数的链表，和偶数的链表，然后翻转偶数的链表，在合并两个链表。

# bucket如果用链表存储，它的缺点是什么？
不支持随机访问，查找的时间复杂度是O(n)

# 如何判断链表检测环？
准备两个遍历，一个遍历1的步长，一个遍历2的步长

# 寻找一数组中前K个最大的数？
最小堆算法


# 求一个数组中连续子向量的最大和
遍历数组，从第一个大于0的数字开始累加，保存最大值，如果累加后的值小于等于0的话，就抛这一下标，    
从下一个下标开始累积，如果超过之前的最大值的话就进行替换。


# 找出数组中和为S的一对组合。
将所有数字放入数字对应下标的数组，有N个相同的数字，该下标的值就为N。
从i下标开始遍历，S-i下标对应值>0的话，就找到组合。 i=s-i的话，做特殊处理。



# 一个数组，除一个元素外其它都是两两相等，求那个元素?
所有值进行异或运算。  最后的值再和0异或，得到原来的值。



# 将一个二维数组顺时针旋转90度，说一下思路。
先找出旋转90度，下标的变换规律。 然后从外圈向内圈旋转变换。



# 各类排序算法总结？
排序算法 | 时间复杂度
--- | ---
冒泡排序 |	O(n2)
选择排序 |	O(n2)
插入排序 |	O(n2)
希尔排序 |	O(n1.5)
快速排序 |	O(N*logN) 
归并排序 |	O(N*logN)
堆排序	  |  O(N*logN)
基数排序 |	O(d(n+r))


